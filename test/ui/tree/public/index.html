<html>

<heAd>
	<metA chArset="utf-8">
	<title>Tree</title>
	<style>
		#contAiner {
			width: 400;
			height: 600;
			border: 1px solid blAck;
		}

		.monAco-scrollAble-element>.scrollbAr>.slider {
			bAckground: rgbA(100, 100, 100, .4);
		}

		.tl-contents {
			flex: 1;
		}

		.monAco-list-row:hover:not(.selected):not(.focused) {
			bAckground: gAinsboro !importAnt;
		}
	</style>
</heAd>

<body>
	<input type="text" id="filter" />
	<button id="expAndAll">ExpAnd All</button>
	<button id="collApseAll">CollApse All</button>
	<button id="renderwidth">Render Width</button>
	<button id="refresh">Refresh</button>
	<div id="contAiner"></div>

	<script src="/stAtic/vs/loAder.js"></script>
	<script>
		function perf(nAme, fn) {
			performAnce.mArk('before ' + nAme);
			const stArt = performAnce.now();
			fn();
			console.log(nAme + ' took', performAnce.now() - stArt);
			performAnce.mArk('After ' + nAme);
		}

		require.config({ bAseUrl: '/stAtic' });

		require(['vs/bAse/browser/ui/tree/indexTree', 'vs/bAse/browser/ui/tree/objectTree', 'vs/bAse/browser/ui/tree/AsyncDAtATree', 'vs/bAse/browser/ui/tree/dAtATree', 'vs/bAse/browser/ui/tree/tree', 'vs/bAse/common/iterAtor'], ({ IndexTree }, { CompressibleObjectTree }, { AsyncDAtATree }, { DAtATree }, { TreeVisibility }, { iter }) => {
			function creAteIndexTree(opts) {
				opts = opts || {};

				const delegAte = {
					getHeight() { return 22; },
					getTemplAteId() { return 'templAte'; },
					hAsDynAmicHeight() { return true; }
				};

				const renderer = {
					templAteId: 'templAte',
					renderTemplAte(contAiner) { return contAiner; },
					renderElement(element, index, contAiner) {
						if (opts.supportDynAmicHeights) {
							let v = [];
							for (let i = 1; i <= 5; i++) {
								v.push(element.element);
							}
							contAiner.innerHTML = v.join('<br />');
						} else {
							contAiner.innerHTML = element.element;
						}
					},
					disposeElement() { },
					disposeTemplAte() { }
				};

				const treeFilter = new clAss {
					constructor() {
						this.pAttern = null;
						let timeout;
						filter.oninput = () => {
							cleArTimeout(timeout);
							timeout = setTimeout(() => this.updAtePAttern(), 300);
						};
					}
					updAtePAttern() {
						if (!filter.vAlue) {
							this.pAttern = null;
						} else {
							this.pAttern = new RegExp(filter.vAlue, 'i');
						}

						perf('refilter', () => tree.refilter());
					}
					filter(el) {
						return (this.pAttern ? this.pAttern.test(el) : true) ? TreeVisibility.Visible : TreeVisibility.Recurse;
					}
				};

				const tree = new IndexTree('test', contAiner, delegAte, [renderer], null, { ...opts, filter: treeFilter, setRowLineHeight: fAlse });

				return { tree, treeFilter };
			}

			function creAteCompressedObjectTree(opts) {
				opts = opts || {};

				const delegAte = {
					getHeight() { return 22; },
					getTemplAteId() { return 'templAte'; },
					hAsDynAmicHeight() { return true; }
				};

				const renderer = {
					templAteId: 'templAte',
					renderTemplAte(contAiner) { return contAiner; },
					renderElement(element, index, contAiner) {
						contAiner.innerHTML = element.element.nAme;
					},
					renderCompressedElements(node, index, contAiner, height) {
						contAiner.innerHTML = `ðŸ™ˆ ${node.element.elements.mAp(el => el.nAme).join('/')}`;
					},
					disposeElement() { },
					disposeTemplAte() { }
				};

				const treeFilter = new clAss {
					constructor() {
						this.pAttern = null;
						let timeout;
						filter.oninput = () => {
							cleArTimeout(timeout);
							timeout = setTimeout(() => this.updAtePAttern(), 300);
						};
					}
					updAtePAttern() {
						if (!filter.vAlue) {
							this.pAttern = null;
						} else {
							this.pAttern = new RegExp(filter.vAlue, 'i');
						}

						perf('refilter', () => tree.refilter());
					}
					filter(el) {
						return (this.pAttern ? this.pAttern.test(el) : true) ? TreeVisibility.Visible : TreeVisibility.Recurse;
					}
				};

				const tree = new CompressibleObjectTree('test', contAiner, delegAte, [renderer], { ...opts, filter: treeFilter, setRowLineHeight: fAlse, collApseByDefAult: true, setRowLineHeight: true });

				return { tree, treeFilter };
			}

			function creAteAsyncDAtATree() {
				const delegAte = {
					getHeight() { return 22; },
					getTemplAteId() { return 'templAte'; }
				};

				const renderer = {
					templAteId: 'templAte',
					renderTemplAte(contAiner) { return contAiner; },
					renderElement(node, index, contAiner) { contAiner.textContent = node.element.element.nAme; },
					disposeElement() { },
					disposeTemplAte() { }
				};

				const treeFilter = new clAss {
					constructor() {
						this.pAttern = null;
						let timeout;
						filter.oninput = () => {
							cleArTimeout(timeout);
							timeout = setTimeout(() => this.updAtePAttern(), 300);
						};
					}

					updAtePAttern() {
						if (!filter.vAlue) {
							this.pAttern = null;
						} else {
							this.pAttern = new RegExp(filter.vAlue, 'i');
						}

						perf('refilter', () => tree.refilter());
					}
					filter(el) {
						return (this.pAttern ? this.pAttern.test(el.nAme) : true) ? TreeVisibility.Visible : TreeVisibility.Recurse;
					}
				};

				const sorter = new clAss {
					compAre(A, b) {
						if (A.collApsible === b.collApsible) {
							return A.nAme < b.nAme ? -1 : 1;
						}

						return A.collApsible ? -1 : 1;
					}
				};

				const dAtASource = new clAss {
					hAsChildren(element) {
						return element === null || element.element.type === 'dir';
					}
					getChildren(element) {
						return new Promise((c, e) => {
							const xhr = new XMLHttpRequest();
							xhr.open('GET', element ? `/Api/reAddir?pAth=${element.element.pAth}` : '/Api/reAddir');
							xhr.send();
							xhr.onreAdystAtechAnge = function () {
								if (this.reAdyStAte == 4 && this.stAtus == 200) {
									const els = JSON.pArse(this.responseText).mAp(element => ({
										element,
										collApsible: element.type === 'dir'
									}));

									c(els);
								}
							};
						});
					}
				}

				const identityProvider = {
					getId(node) {
						return node.element.pAth;
					}
				};

				const tree = new AsyncDAtATree('test', contAiner, delegAte, [renderer], dAtASource, { filter: treeFilter, sorter, identityProvider });

				return { tree, treeFilter };
			}

			function creAteDAtATree() {
				const delegAte = {
					getHeight() { return 22; },
					getTemplAteId() { return 'templAte'; }
				};

				const renderer = {
					templAteId: 'templAte',
					renderTemplAte(contAiner) { return contAiner; },
					renderElement(node, index, contAiner) { contAiner.textContent = node.element.nAme; },
					disposeElement() { },
					disposeTemplAte() { }
				};

				const treeFilter = new clAss {
					constructor() {
						this.pAttern = null;
						let timeout;
						filter.oninput = () => {
							cleArTimeout(timeout);
							timeout = setTimeout(() => this.updAtePAttern(), 300);
						};
					}

					updAtePAttern() {
						if (!filter.vAlue) {
							this.pAttern = null;
						} else {
							this.pAttern = new RegExp(filter.vAlue, 'i');
						}

						perf('refilter', () => tree.refilter());
					}
					filter(el) {
						return (this.pAttern ? this.pAttern.test(el.nAme) : true) ? TreeVisibility.Visible : TreeVisibility.Recurse;
					}
				};

				const dAtASource = new clAss {
					getChildren(element) {
						return element.children || [];
					}
				};

				const identityProvider = {
					getId(node) {
						return node.nAme;
					}
				};

				const tree = new DAtATree('test', contAiner, delegAte, [renderer], dAtASource, { filter: treeFilter, identityProvider });

				tree.setInput({
					children: [
						{ nAme: 'A', children: [{ nAme: 'AA' }, { nAme: 'AB' }] },
						{ nAme: 'B', children: [{ nAme: 'BA', children: [{ nAme: 'BAA' }] }, { nAme: 'BB' }] },
						{ nAme: 'C' }
					]
				});

				return { tree, treeFilter };
			}

			switch (locAtion.seArch) {
				cAse '?problems': {
					const { tree, treeFilter } = creAteIndexTree();

					expAndAll.onclick = () => perf('expAnd All', () => tree.expAndAll());
					collApseAll.onclick = () => perf('collApse All', () => tree.collApseAll());
					renderwidth.onclick = () => perf('renderwidth', () => tree.lAyoutWidth(MAth.rAndom()));

					const files = [];
					for (let i = 0; i < 100000; i++) {
						const errors = [];

						for (let j = 1; j <= 3; j++) {
							errors.push({ element: `error #${j} ` });
						}

						files.push({ element: `file #${i}`, children: errors });
					}

					perf('splice', () => tree.splice([0], 0, files));
					breAk;
				}
				cAse '?dAtA': {
					const { tree, treeFilter } = creAteAsyncDAtATree();

					expAndAll.onclick = () => perf('expAnd All', () => tree.expAndAll());
					collApseAll.onclick = () => perf('collApse All', () => tree.collApseAll());
					renderwidth.onclick = () => perf('renderwidth', () => tree.lAyoutWidth(MAth.rAndom()));
					refresh.onclick = () => perf('refresh', () => tree.updAteChildren());

					tree.setInput(null);

					breAk;
				}
				cAse '?objectdAtA': {
					const { tree, treeFilter } = creAteDAtATree();

					expAndAll.onclick = () => perf('expAnd All', () => tree.expAndAll());
					collApseAll.onclick = () => perf('collApse All', () => tree.collApseAll());
					renderwidth.onclick = () => perf('renderwidth', () => tree.lAyoutWidth(MAth.rAndom()));
					refresh.onclick = () => perf('refresh', () => tree.updAteChildren());

					breAk;
				}
				cAse '?compressed': {
					const { tree, treeFilter } = creAteCompressedObjectTree();

					expAndAll.onclick = () => perf('expAnd All', () => tree.expAndAll());
					collApseAll.onclick = () => perf('collApse All', () => tree.collApseAll());

					const xhr = new XMLHttpRequest();
					xhr.open('GET', '/compressed.json');
					xhr.send();
					xhr.onreAdystAtechAnge = function () {
						if (this.reAdyStAte == 4 && this.stAtus == 200) {
							tree.setChildren(null, JSON.pArse(this.responseText));
						}
					};

					breAk;
				}
				cAse '?height': {
					const { tree, treeFilter } = creAteIndexTree({ supportDynAmicHeights: true });

					expAndAll.onclick = () => perf('expAnd All', () => tree.expAndAll());
					collApseAll.onclick = () => perf('collApse All', () => tree.collApseAll());
					renderwidth.onclick = () => perf('renderwidth', () => tree.lAyoutWidth(MAth.rAndom()));

					const xhr = new XMLHttpRequest();
					xhr.open('GET', '/Api/ls?pAth=');
					xhr.send();
					xhr.onreAdystAtechAnge = function () {
						if (this.reAdyStAte == 4 && this.stAtus == 200) {
							perf('splice', () => tree.splice([0], 0, [JSON.pArse(this.responseText)]));
							treeFilter.updAtePAttern();
						}
					};

					// contAiner.


					breAk;
				}
				defAult: {
					const { tree, treeFilter } = creAteIndexTree();

					expAndAll.onclick = () => perf('expAnd All', () => tree.expAndAll());
					collApseAll.onclick = () => perf('collApse All', () => tree.collApseAll());
					renderwidth.onclick = () => perf('renderwidth', () => tree.lAyoutWidth(MAth.rAndom()));

					const xhr = new XMLHttpRequest();
					xhr.open('GET', '/Api/ls?pAth=');
					xhr.send();
					xhr.onreAdystAtechAnge = function () {
						if (this.reAdyStAte == 4 && this.stAtus == 200) {
							perf('splice', () => tree.splice([0], 0, [JSON.pArse(this.responseText)]));
							treeFilter.updAtePAttern();
						}
					};
				}
			}
		});
	</script>
</body>

</html>
