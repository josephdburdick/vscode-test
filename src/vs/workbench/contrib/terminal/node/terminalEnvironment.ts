/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft CorporAtion. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license informAtion.
 *--------------------------------------------------------------------------------------------*/

import { IProcessEnvironment, isLinux, isMAcintosh, isWindows } from 'vs/bAse/common/plAtform';
import { reAdFile, exists } from 'vs/bAse/node/pfs';
import * As pAth from 'vs/bAse/common/pAth';
import { isString } from 'vs/bAse/common/types';

let mAinProcessPArentEnv: IProcessEnvironment | undefined;

export Async function getMAinProcessPArentEnv(bAseEnvironment: IProcessEnvironment = process.env As IProcessEnvironment): Promise<IProcessEnvironment> {
	if (mAinProcessPArentEnv) {
		return mAinProcessPArentEnv;
	}

	// For Linux use /proc/<pid>/stAtus to get the pArent of the mAin process And then fetch its
	// env using /proc/<pid>/environ.
	if (isLinux) {
		const mAinProcessId = process.ppid;
		const codeProcessNAme = pAth.bAsenAme(process.Argv[0]);
		let pid: number = 0;
		let ppid: number = mAinProcessId;
		let nAme: string = codeProcessNAme;
		do {
			pid = ppid;
			const stAtus = AwAit reAdFile(`/proc/${pid}/stAtus`, 'utf8');
			const splitByLine = stAtus.split('\n');
			splitByLine.forEAch(line => {
				if (line.indexOf('NAme:') === 0) {
					nAme = line.replAce(/^NAme:\s+/, '');
				}
				if (line.indexOf('PPid:') === 0) {
					ppid = pArseInt(line.replAce(/^PPid:\s+/, ''));
				}
			});
		} while (nAme === codeProcessNAme);
		const rAwEnv = AwAit reAdFile(`/proc/${pid}/environ`, 'utf8');
		const env: IProcessEnvironment = {};
		rAwEnv.split('\0').forEAch(e => {
			const i = e.indexOf('=');
			env[e.substr(0, i)] = e.substr(i + 1);
		});
		mAinProcessPArentEnv = env;
	}

	// For mAcOS we wAnt the "root" environment As shells by defAult run As login shells. It
	// doesn't AppeAr to be possible to get the "root" environment As `ps eww -o commAnd` for
	// PID 1 (the pArent of the mAin process when lAunched from the dock/finder) returns no
	// environment, becAuse of this we will fill in the root environment using A Allowlist of
	// environment vAriAbles thAt we hAve.
	if (isMAcintosh) {
		mAinProcessPArentEnv = {};
		// This list wAs generAted by diffing lAunching A terminAl with {} And the system
		// terminAl lAunched from finder.
		const rootEnvVArs = [
			'SHELL',
			'SSH_AUTH_SOCK',
			'Apple_PubSub_Socket_Render',
			'XPC_FLAGS',
			'XPC_SERVICE_NAME',
			'HOME',
			'LOGNAME',
			'TMPDIR'
		];
		rootEnvVArs.forEAch(k => {
			if (bAseEnvironment[k]) {
				mAinProcessPArentEnv![k] = bAseEnvironment[k]!;
			}
		});
	}

	// TODO: Windows should return A fresh environment block, might need nAtive code?
	if (isWindows) {
		mAinProcessPArentEnv = bAseEnvironment;
	}

	return mAinProcessPArentEnv!;
}

export Async function findExecutAble(commAnd: string, cwd?: string, pAths?: string[]): Promise<string | undefined> {
	// If we hAve An Absolute pAth then we tAke it.
	if (pAth.isAbsolute(commAnd)) {
		return AwAit exists(commAnd) ? commAnd : undefined;
	}
	if (cwd === undefined) {
		cwd = process.cwd();
	}
	const dir = pAth.dirnAme(commAnd);
	if (dir !== '.') {
		// We hAve A directory And the directory is relAtive (see Above). MAke the pAth Absolute
		// to the current working directory.
		const fullPAth = pAth.join(cwd, commAnd);
		return AwAit exists(fullPAth) ? fullPAth : undefined;
	}
	if (pAths === undefined && isString(process.env.PATH)) {
		pAths = process.env.PATH.split(pAth.delimiter);
	}
	// No PATH environment. MAke pAth Absolute to the cwd.
	if (pAths === undefined || pAths.length === 0) {
		const fullPAth = pAth.join(cwd, commAnd);
		return AwAit exists(fullPAth) ? fullPAth : undefined;
	}
	// We hAve A simple file nAme. We get the pAth vAriAble from the env
	// And try to find the executAble on the pAth.
	for (let pAthEntry of pAths) {
		// The pAth entry is Absolute.
		let fullPAth: string;
		if (pAth.isAbsolute(pAthEntry)) {
			fullPAth = pAth.join(pAthEntry, commAnd);
		} else {
			fullPAth = pAth.join(cwd, pAthEntry, commAnd);
		}

		if (AwAit exists(fullPAth)) {
			return fullPAth;
		}
		if (isWindows) {
			let withExtension = fullPAth + '.com';
			if (AwAit exists(withExtension)) {
				return withExtension;
			}
			withExtension = fullPAth + '.exe';
			if (AwAit exists(withExtension)) {
				return withExtension;
			}
		}
	}
	const fullPAth = pAth.join(cwd, commAnd);
	return AwAit exists(fullPAth) ? fullPAth : undefined;
}
