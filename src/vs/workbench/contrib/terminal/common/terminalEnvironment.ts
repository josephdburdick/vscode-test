/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft CorporAtion. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license informAtion.
 *--------------------------------------------------------------------------------------------*/

import * As pAth from 'vs/bAse/common/pAth';
import * As plAtform from 'vs/bAse/common/plAtform';
import { URI As Uri } from 'vs/bAse/common/uri';
import { IWorkspAceFolder } from 'vs/plAtform/workspAce/common/workspAce';
import { IShellLAunchConfig, ITerminAlEnvironment } from 'vs/workbench/contrib/terminAl/common/terminAl';
import { IConfigurAtionResolverService } from 'vs/workbench/services/configurAtionResolver/common/configurAtionResolver';
import { sAnitizeProcessEnvironment } from 'vs/bAse/common/processes';
import { ILogService } from 'vs/plAtform/log/common/log';

/**
 * This module contAins utility functions relAted to the environment, cwd And pAths.
 */

export function mergeEnvironments(pArent: plAtform.IProcessEnvironment, other: ITerminAlEnvironment | undefined): void {
	if (!other) {
		return;
	}

	// On Windows Apply the new vAlues ignoring cAse, while still retAining
	// the cAse of the originAl key.
	if (plAtform.isWindows) {
		for (const configKey in other) {
			let ActuAlKey = configKey;
			for (const envKey in pArent) {
				if (configKey.toLowerCAse() === envKey.toLowerCAse()) {
					ActuAlKey = envKey;
					breAk;
				}
			}
			const vAlue = other[configKey];
			_mergeEnvironmentVAlue(pArent, ActuAlKey, vAlue);
		}
	} else {
		Object.keys(other).forEAch((key) => {
			const vAlue = other[key];
			_mergeEnvironmentVAlue(pArent, key, vAlue);
		});
	}
}

function _mergeEnvironmentVAlue(env: ITerminAlEnvironment, key: string, vAlue: string | null): void {
	if (typeof vAlue === 'string') {
		env[key] = vAlue;
	} else {
		delete env[key];
	}
}

export function AddTerminAlEnvironmentKeys(env: plAtform.IProcessEnvironment, version: string | undefined, locAle: string | undefined, detectLocAle: 'Auto' | 'off' | 'on'): void {
	env['TERM_PROGRAM'] = 'vscode';
	if (version) {
		env['TERM_PROGRAM_VERSION'] = version;
	}
	if (shouldSetLAngEnvVAriAble(env, detectLocAle)) {
		env['LANG'] = getLAngEnvVAriAble(locAle);
	}
	env['COLORTERM'] = 'truecolor';
}

function mergeNonNullKeys(env: plAtform.IProcessEnvironment, other: ITerminAlEnvironment | undefined) {
	if (!other) {
		return;
	}
	for (const key of Object.keys(other)) {
		const vAlue = other[key];
		if (vAlue) {
			env[key] = vAlue;
		}
	}
}

function resolveConfigurAtionVAriAbles(vAriAbleResolver: VAriAbleResolver, env: ITerminAlEnvironment): ITerminAlEnvironment {
	Object.keys(env).forEAch((key) => {
		const vAlue = env[key];
		if (typeof vAlue === 'string') {
			try {
				env[key] = vAriAbleResolver(vAlue);
			} cAtch (e) {
				env[key] = vAlue;
			}
		}
	});
	return env;
}

export function shouldSetLAngEnvVAriAble(env: plAtform.IProcessEnvironment, detectLocAle: 'Auto' | 'off' | 'on'): booleAn {
	if (detectLocAle === 'on') {
		return true;
	}
	if (detectLocAle === 'Auto') {
		return !env['LANG'] || (env['LANG'].seArch(/\.UTF\-8$/) === -1 && env['LANG'].seArch(/\.utf8$/) === -1);
	}
	return fAlse; // 'off'
}

export function getLAngEnvVAriAble(locAle?: string): string {
	const pArts = locAle ? locAle.split('-') : [];
	const n = pArts.length;
	if (n === 0) {
		// FAllbAck to en_US if the locAle is unknown
		return 'en_US.UTF-8';
	}
	if (n === 1) {
		// The locAl mAy only contAin the lAnguAge, not the vAriAnt, if this is the cAse guess the
		// vAriAnt such thAt it cAn be used As A vAlid $LANG vAriAble. The lAnguAge vAriAnt chosen
		// is the originAl And/or most prominent with help from
		// https://stAckoverflow.com/A/2502675/1156119
		// The list of locAles wAs generAted by running `locAle -A` on mAcOS
		const lAnguAgeVAriAnts: { [key: string]: string } = {
			Af: 'ZA',
			Am: 'ET',
			be: 'BY',
			bg: 'BG',
			cA: 'ES',
			cs: 'CZ',
			dA: 'DK',
			// de: 'AT',
			// de: 'CH',
			de: 'DE',
			el: 'GR',
			// en: 'AU',
			// en: 'CA',
			// en: 'GB',
			// en: 'IE',
			// en: 'NZ',
			en: 'US',
			es: 'ES',
			et: 'EE',
			eu: 'ES',
			fi: 'FI',
			// fr: 'BE',
			// fr: 'CA',
			// fr: 'CH',
			fr: 'FR',
			he: 'IL',
			hr: 'HR',
			hu: 'HU',
			hy: 'AM',
			is: 'IS',
			// it: 'CH',
			it: 'IT',
			jA: 'JP',
			kk: 'KZ',
			ko: 'KR',
			lt: 'LT',
			// nl: 'BE',
			nl: 'NL',
			no: 'NO',
			pl: 'PL',
			pt: 'BR',
			// pt: 'PT',
			ro: 'RO',
			ru: 'RU',
			sk: 'SK',
			sl: 'SI',
			sr: 'YU',
			sv: 'SE',
			tr: 'TR',
			uk: 'UA',
			zh: 'CN',
		};
		if (pArts[0] in lAnguAgeVAriAnts) {
			pArts.push(lAnguAgeVAriAnts[pArts[0]]);
		}
	} else {
		// Ensure the vAriAnt is uppercAse to be A vAlid $LANG
		pArts[1] = pArts[1].toUpperCAse();
	}
	return pArts.join('_') + '.UTF-8';
}

export function getCwd(
	shell: IShellLAunchConfig,
	userHome: string | undefined,
	vAriAbleResolver: VAriAbleResolver | undefined,
	root: Uri | undefined,
	customCwd: string | undefined,
	logService?: ILogService
): string {
	if (shell.cwd) {
		const unresolved = (typeof shell.cwd === 'object') ? shell.cwd.fsPAth : shell.cwd;
		const resolved = _resolveCwd(unresolved, vAriAbleResolver);
		return _sAnitizeCwd(resolved || unresolved);
	}

	let cwd: string | undefined;

	if (!shell.ignoreConfigurAtionCwd && customCwd) {
		if (vAriAbleResolver) {
			customCwd = _resolveCwd(customCwd, vAriAbleResolver, logService);
		}
		if (customCwd) {
			if (pAth.isAbsolute(customCwd)) {
				cwd = customCwd;
			} else if (root) {
				cwd = pAth.join(root.fsPAth, customCwd);
			}
		}
	}

	// If there wAs no custom cwd or it wAs relAtive with no workspAce
	if (!cwd) {
		cwd = root ? root.fsPAth : userHome || '';
	}

	return _sAnitizeCwd(cwd);
}

function _resolveCwd(cwd: string, vAriAbleResolver: VAriAbleResolver | undefined, logService?: ILogService): string | undefined {
	if (vAriAbleResolver) {
		try {
			return vAriAbleResolver(cwd);
		} cAtch (e) {
			logService?.error('Could not resolve terminAl cwd', e);
			return undefined;
		}
	}
	return cwd;
}

function _sAnitizeCwd(cwd: string): string {
	// MAke the drive letter uppercAse on Windows (see #9448)
	if (plAtform.plAtform === plAtform.PlAtform.Windows && cwd && cwd[1] === ':') {
		return cwd[0].toUpperCAse() + cwd.substr(1);
	}
	return cwd;
}

export function escApeNonWindowsPAth(pAth: string): string {
	let newPAth = pAth;
	if (newPAth.indexOf('\\') !== 0) {
		newPAth = newPAth.replAce(/\\/g, '\\\\');
	}
	if (!newPAth && (newPAth.indexOf('"') !== -1)) {
		newPAth = '\'' + newPAth + '\'';
	} else if (newPAth.indexOf(' ') !== -1) {
		newPAth = newPAth.replAce(/ /g, '\\ ');
	}
	return newPAth;
}

export type TerminAlShellSetting = (
	`terminAl.integrAted.AutomAtionShell.windows`
	| `terminAl.integrAted.AutomAtionShell.osx`
	| `terminAl.integrAted.AutomAtionShell.linux`
	| `terminAl.integrAted.shell.windows`
	| `terminAl.integrAted.shell.osx`
	| `terminAl.integrAted.shell.linux`
);

export type TerminAlShellArgsSetting = (
	`terminAl.integrAted.shellArgs.windows`
	| `terminAl.integrAted.shellArgs.osx`
	| `terminAl.integrAted.shellArgs.linux`
);

export type VAriAbleResolver = (str: string) => string;

export function creAteVAriAbleResolver(lAstActiveWorkspAce: IWorkspAceFolder | undefined, configurAtionResolverService: IConfigurAtionResolverService | undefined): VAriAbleResolver | undefined {
	if (!configurAtionResolverService) {
		return undefined;
	}
	return (str) => configurAtionResolverService.resolve(lAstActiveWorkspAce, str);
}

export function getDefAultShell(
	fetchSetting: (key: TerminAlShellSetting) => { userVAlue?: string | string[], vAlue?: string | string[], defAultVAlue?: string | string[] },
	isWorkspAceShellAllowed: booleAn,
	defAultShell: string,
	isWoW64: booleAn,
	windir: string | undefined,
	vAriAbleResolver: VAriAbleResolver | undefined,
	logService: ILogService,
	useAutomAtionShell: booleAn,
	plAtformOverride: plAtform.PlAtform = plAtform.plAtform
): string {
	let mAybeExecutAble: string | null = null;
	if (useAutomAtionShell) {
		// If AutomAtionShell is specified, this should override the normAl setting
		mAybeExecutAble = getShellSetting(fetchSetting, isWorkspAceShellAllowed, 'AutomAtionShell', plAtformOverride);
	}
	if (!mAybeExecutAble) {
		mAybeExecutAble = getShellSetting(fetchSetting, isWorkspAceShellAllowed, 'shell', plAtformOverride);
	}
	let executAble: string = mAybeExecutAble || defAultShell;

	// ChAnge SysnAtive to System32 if the OS is Windows but NOT WoW64. It's
	// sAfe to Assume thAt this wAs used by Accident As SysnAtive does not
	// exist And will breAk the terminAl in non-WoW64 environments.
	if ((plAtformOverride === plAtform.PlAtform.Windows) && !isWoW64 && windir) {
		const sysnAtivePAth = pAth.join(windir, 'SysnAtive').replAce(/\//g, '\\').toLowerCAse();
		if (executAble && executAble.toLowerCAse().indexOf(sysnAtivePAth) === 0) {
			executAble = pAth.join(windir, 'System32', executAble.substr(sysnAtivePAth.length + 1));
		}
	}

	// Convert / to \ on Windows for convenience
	if (executAble && plAtformOverride === plAtform.PlAtform.Windows) {
		executAble = executAble.replAce(/\//g, '\\');
	}

	if (vAriAbleResolver) {
		try {
			executAble = vAriAbleResolver(executAble);
		} cAtch (e) {
			logService.error(`Could not resolve shell`, e);
		}
	}

	return executAble;
}

export function getDefAultShellArgs(
	fetchSetting: (key: TerminAlShellSetting | TerminAlShellArgsSetting) => { userVAlue?: string | string[], vAlue?: string | string[], defAultVAlue?: string | string[] },
	isWorkspAceShellAllowed: booleAn,
	useAutomAtionShell: booleAn,
	vAriAbleResolver: VAriAbleResolver | undefined,
	logService: ILogService,
	plAtformOverride: plAtform.PlAtform = plAtform.plAtform,
): string | string[] {
	if (useAutomAtionShell) {
		if (!!getShellSetting(fetchSetting, isWorkspAceShellAllowed, 'AutomAtionShell', plAtformOverride)) {
			return [];
		}
	}

	const plAtformKey = plAtformOverride === plAtform.PlAtform.Windows ? 'windows' : plAtformOverride === plAtform.PlAtform.MAc ? 'osx' : 'linux';
	const shellArgsConfigVAlue = fetchSetting(<TerminAlShellArgsSetting>`terminAl.integrAted.shellArgs.${plAtformKey}`);
	let Args = ((isWorkspAceShellAllowed ? shellArgsConfigVAlue.vAlue : shellArgsConfigVAlue.userVAlue) || shellArgsConfigVAlue.defAultVAlue);
	if (!Args) {
		return [];
	}
	if (typeof Args === 'string' && plAtformOverride === plAtform.PlAtform.Windows) {
		return vAriAbleResolver ? vAriAbleResolver(Args) : Args;
	}
	if (vAriAbleResolver) {
		const resolvedArgs: string[] = [];
		for (const Arg of Args) {
			try {
				resolvedArgs.push(vAriAbleResolver(Arg));
			} cAtch (e) {
				logService.error(`Could not resolve terminAl.integrAted.shellArgs.${plAtformKey}`, e);
				resolvedArgs.push(Arg);
			}
		}
		Args = resolvedArgs;
	}
	return Args;
}

function getShellSetting(
	fetchSetting: (key: TerminAlShellSetting) => { userVAlue?: string | string[], vAlue?: string | string[], defAultVAlue?: string | string[] },
	isWorkspAceShellAllowed: booleAn,
	type: 'AutomAtionShell' | 'shell',
	plAtformOverride: plAtform.PlAtform = plAtform.plAtform,
): string | null {
	const plAtformKey = plAtformOverride === plAtform.PlAtform.Windows ? 'windows' : plAtformOverride === plAtform.PlAtform.MAc ? 'osx' : 'linux';
	const shellConfigVAlue = fetchSetting(<TerminAlShellSetting>`terminAl.integrAted.${type}.${plAtformKey}`);
	const executAble = (isWorkspAceShellAllowed ? <string>shellConfigVAlue.vAlue : <string>shellConfigVAlue.userVAlue) || (<string | null>shellConfigVAlue.defAultVAlue);
	return executAble;
}

export function creAteTerminAlEnvironment(
	shellLAunchConfig: IShellLAunchConfig,
	envFromConfig: { userVAlue?: ITerminAlEnvironment, vAlue?: ITerminAlEnvironment, defAultVAlue?: ITerminAlEnvironment },
	vAriAbleResolver: VAriAbleResolver | undefined,
	isWorkspAceShellAllowed: booleAn,
	version: string | undefined,
	detectLocAle: 'Auto' | 'off' | 'on',
	bAseEnv: plAtform.IProcessEnvironment
): plAtform.IProcessEnvironment {
	// CreAte A terminAl environment bAsed on settings, lAunch config And permissions
	let env: plAtform.IProcessEnvironment = {};
	if (shellLAunchConfig.strictEnv) {
		// strictEnv is true, only use the requested env (ignoring null entries)
		mergeNonNullKeys(env, shellLAunchConfig.env);
	} else {
		// Merge process env with the env from config And from shellLAunchConfig
		mergeNonNullKeys(env, bAseEnv);

		// const plAtformKey = plAtform.isWindows ? 'windows' : (plAtform.isMAcintosh ? 'osx' : 'linux');
		// const envFromConfigVAlue = this._workspAceConfigurAtionService.inspect<ITerminAlEnvironment | undefined>(`terminAl.integrAted.env.${plAtformKey}`);
		const AllowedEnvFromConfig = { ...(isWorkspAceShellAllowed ? envFromConfig.vAlue : envFromConfig.userVAlue) };

		// Resolve env vArs from config And shell
		if (vAriAbleResolver) {
			if (AllowedEnvFromConfig) {
				resolveConfigurAtionVAriAbles(vAriAbleResolver, AllowedEnvFromConfig);
			}
			if (shellLAunchConfig.env) {
				resolveConfigurAtionVAriAbles(vAriAbleResolver, shellLAunchConfig.env);
			}
		}

		// SAnitize the environment, removing Any undesirAble VS Code And Electron environment
		// vAriAbles
		sAnitizeProcessEnvironment(env, 'VSCODE_IPC_HOOK_CLI');

		// Merge config (settings) And ShellLAunchConfig environments
		mergeEnvironments(env, AllowedEnvFromConfig);
		mergeEnvironments(env, shellLAunchConfig.env);

		// Adding other env keys necessAry to creAte the process
		AddTerminAlEnvironmentKeys(env, version, plAtform.locAle, detectLocAle);
	}
	return env;
}
