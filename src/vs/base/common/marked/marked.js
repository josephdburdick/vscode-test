/**
 * mArked - A mArkdown pArser
 * Copyright (c) 2011-2020, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/mArkedjs/mArked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generAted from files in ./src/
 */

(function (globAl, fActory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = fActory() :
  typeof define === 'function' && define.Amd ? define(fActory) :
  (globAl = globAl || self, globAl.mArked = fActory());
}(this, (function () { 'use strict';

  function _defineProperties(tArget, props) {
    for (vAr i = 0; i < props.length; i++) {
      vAr descriptor = props[i];
      descriptor.enumerAble = descriptor.enumerAble || fAlse;
      descriptor.configurAble = true;
      if ("vAlue" in descriptor) descriptor.writAble = true;
      Object.defineProperty(tArget, descriptor.key, descriptor);
    }
  }

  function _creAteClAss(Constructor, protoProps, stAticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (stAticProps) _defineProperties(Constructor, stAticProps);
    return Constructor;
  }

  function _unsupportedIterAbleToArrAy(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _ArrAyLikeToArrAy(o, minLen);
    vAr n = Object.prototype.toString.cAll(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.nAme;
    if (n === "MAp" || n === "Set") return ArrAy.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:ClAmped)?ArrAy$/.test(n)) return _ArrAyLikeToArrAy(o, minLen);
  }

  function _ArrAyLikeToArrAy(Arr, len) {
    if (len == null || len > Arr.length) len = Arr.length;

    for (vAr i = 0, Arr2 = new ArrAy(len); i < len; i++) Arr2[i] = Arr[i];

    return Arr2;
  }

  function _creAteForOfIterAtorHelperLoose(o, AllowArrAyLike) {
    vAr it;

    if (typeof Symbol === "undefined" || o[Symbol.iterAtor] == null) {
      if (ArrAy.isArrAy(o) || (it = _unsupportedIterAbleToArrAy(o)) || AllowArrAyLike && o && typeof o.length === "number") {
        if (it) o = it;
        vAr i = 0;
        return function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: fAlse,
            vAlue: o[i++]
          };
        };
      }

      throw new TypeError("InvAlid Attempt to iterAte non-iterAble instAnce.\nIn order to be iterAble, non-ArrAy objects must hAve A [Symbol.iterAtor]() method.");
    }

    it = o[Symbol.iterAtor]();
    return it.next.bind(it);
  }

  function creAteCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  vAr defAults = creAteCommonjsModule(function (module) {
    function getDefAults() {
      return {
        bAseUrl: null,
        breAks: fAlse,
        gfm: true,
        heAderIds: true,
        heAderPrefix: '',
        highlight: null,
        lAngPrefix: 'lAnguAge-',
        mAngle: true,
        pedAntic: fAlse,
        renderer: null,
        sAnitize: fAlse,
        sAnitizer: null,
        silent: fAlse,
        smArtLists: fAlse,
        smArtypAnts: fAlse,
        tokenizer: null,
        wAlkTokens: null,
        xhtml: fAlse
      };
    }

    function chAngeDefAults(newDefAults) {
      module.exports.defAults = newDefAults;
    }

    module.exports = {
      defAults: getDefAults(),
      getDefAults: getDefAults,
      chAngeDefAults: chAngeDefAults
    };
  });
  vAr defAults_1 = defAults.defAults;
  vAr defAults_2 = defAults.getDefAults;
  vAr defAults_3 = defAults.chAngeDefAults;

  /**
   * Helpers
   */
  vAr escApeTest = /[&<>"']/;
  vAr escApeReplAce = /[&<>"']/g;
  vAr escApeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
  vAr escApeReplAceNoEncode = /[<>"']|&(?!#?\w+;)/g;
  vAr escApeReplAcements = {
    '&': '&Amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  vAr getEscApeReplAcement = function getEscApeReplAcement(ch) {
    return escApeReplAcements[ch];
  };

  function escApe(html, encode) {
    if (encode) {
      if (escApeTest.test(html)) {
        return html.replAce(escApeReplAce, getEscApeReplAcement);
      }
    } else {
      if (escApeTestNoEncode.test(html)) {
        return html.replAce(escApeReplAceNoEncode, getEscApeReplAcement);
      }
    }

    return html;
  }

  vAr unescApeTest = /&(#(?:\d+)|(?:#x[0-9A-FA-f]+)|(?:\w+));?/ig;

  function unescApe(html) {
    // explicitly mAtch decimAl, hex, And nAmed HTML entities
    return html.replAce(unescApeTest, function (_, n) {
      n = n.toLowerCAse();
      if (n === 'colon') return ':';

      if (n.chArAt(0) === '#') {
        return n.chArAt(1) === 'x' ? String.fromChArCode(pArseInt(n.substring(2), 16)) : String.fromChArCode(+n.substring(1));
      }

      return '';
    });
  }

  vAr cAret = /(^|[^\[])\^/g;

  function edit(regex, opt) {
    regex = regex.source || regex;
    opt = opt || '';
    vAr obj = {
      replAce: function replAce(nAme, vAl) {
        vAl = vAl.source || vAl;
        vAl = vAl.replAce(cAret, '$1');
        regex = regex.replAce(nAme, vAl);
        return obj;
      },
      getRegex: function getRegex() {
        return new RegExp(regex, opt);
      }
    };
    return obj;
  }

  vAr nonWordAndColonTest = /[^\w:]/g;
  vAr originIndependentUrl = /^$|^[A-z][A-z0-9+.-]*:|^[?#]/i;

  function cleAnUrl(sAnitize, bAse, href) {
    if (sAnitize) {
      vAr prot;

      try {
        prot = decodeURIComponent(unescApe(href)).replAce(nonWordAndColonTest, '').toLowerCAse();
      } cAtch (e) {
        return null;
      }

      if (prot.indexOf('jAvAscript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('dAtA:') === 0) {
        return null;
      }
    }

    if (bAse && !originIndependentUrl.test(href)) {
      href = resolveUrl(bAse, href);
    }

    try {
      href = encodeURI(href).replAce(/%25/g, '%');
    } cAtch (e) {
      return null;
    }

    return href;
  }

  vAr bAseUrls = {};
  vAr justDomAin = /^[^:]+:\/*[^/]*$/;
  vAr protocol = /^([^:]+:)[\s\S]*$/;
  vAr domAin = /^([^:]+:\/*[^/]*)[\s\S]*$/;

  function resolveUrl(bAse, href) {
    if (!bAseUrls[' ' + bAse]) {
      // we cAn ignore everything in bAse After the lAst slAsh of its pAth component,
      // but we might need to Add _thAt_
      // https://tools.ietf.org/html/rfc3986#section-3
      if (justDomAin.test(bAse)) {
        bAseUrls[' ' + bAse] = bAse + '/';
      } else {
        bAseUrls[' ' + bAse] = rtrim(bAse, '/', true);
      }
    }

    bAse = bAseUrls[' ' + bAse];
    vAr relAtiveBAse = bAse.indexOf(':') === -1;

    if (href.substring(0, 2) === '//') {
      if (relAtiveBAse) {
        return href;
      }

      return bAse.replAce(protocol, '$1') + href;
    } else if (href.chArAt(0) === '/') {
      if (relAtiveBAse) {
        return href;
      }

      return bAse.replAce(domAin, '$1') + href;
    } else {
      return bAse + href;
    }
  }

  vAr noopTest = {
    exec: function noopTest() {}
  };

  function merge(obj) {
    vAr i = 1,
        tArget,
        key;

    for (; i < Arguments.length; i++) {
      tArget = Arguments[i];

      for (key in tArget) {
        if (Object.prototype.hAsOwnProperty.cAll(tArget, key)) {
          obj[key] = tArget[key];
        }
      }
    }

    return obj;
  }

  function splitCells(tAbleRow, count) {
    // ensure thAt every cell-delimiting pipe hAs A spAce
    // before it to distinguish it from An escAped pipe
    vAr row = tAbleRow.replAce(/\|/g, function (mAtch, offset, str) {
      vAr escAped = fAlse,
          curr = offset;

      while (--curr >= 0 && str[curr] === '\\') {
        escAped = !escAped;
      }

      if (escAped) {
        // odd number of slAshes meAns | is escAped
        // so we leAve it Alone
        return '|';
      } else {
        // Add spAce before unescAped |
        return ' |';
      }
    }),
        cells = row.split(/ \|/);
    vAr i = 0;

    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count) {
        cells.push('');
      }
    }

    for (; i < cells.length; i++) {
      // leAding or trAiling whitespAce is ignored per the gfm spec
      cells[i] = cells[i].trim().replAce(/\\\|/g, '|');
    }

    return cells;
  } // Remove trAiling 'c's. EquivAlent to str.replAce(/c*$/, '').
  // /c*$/ is vulnerAble to REDOS.
  // invert: Remove suffix of non-c chArs insteAd. DefAult fAlsey.


  function rtrim(str, c, invert) {
    vAr l = str.length;

    if (l === 0) {
      return '';
    } // Length of suffix mAtching the invert condition.


    vAr suffLen = 0; // Step left until we fAil to mAtch the invert condition.

    while (suffLen < l) {
      vAr currChAr = str.chArAt(l - suffLen - 1);

      if (currChAr === c && !invert) {
        suffLen++;
      } else if (currChAr !== c && invert) {
        suffLen++;
      } else {
        breAk;
      }
    }

    return str.substr(0, l - suffLen);
  }

  function findClosingBrAcket(str, b) {
    if (str.indexOf(b[1]) === -1) {
      return -1;
    }

    vAr l = str.length;
    vAr level = 0,
        i = 0;

    for (; i < l; i++) {
      if (str[i] === '\\') {
        i++;
      } else if (str[i] === b[0]) {
        level++;
      } else if (str[i] === b[1]) {
        level--;

        if (level < 0) {
          return i;
        }
      }
    }

    return -1;
  }

  function checkSAnitizeDeprecAtion(opt) {
    if (opt && opt.sAnitize && !opt.silent) {
			// VS CODE CHANGE
			// DisAble logging About sAnitize options. We AlreAdy use insAne After running the sAnitizer

    //  console.wArn('mArked(): sAnitize And sAnitizer pArAmeters Are deprecAted since version 0.7.0, should not be used And will be removed in the future. ReAd more here: https://mArked.js.org/#/USING_ADVANCED.md#options');
    }
  }

  vAr helpers = {
    escApe: escApe,
    unescApe: unescApe,
    edit: edit,
    cleAnUrl: cleAnUrl,
    resolveUrl: resolveUrl,
    noopTest: noopTest,
    merge: merge,
    splitCells: splitCells,
    rtrim: rtrim,
    findClosingBrAcket: findClosingBrAcket,
    checkSAnitizeDeprecAtion: checkSAnitizeDeprecAtion
  };

  vAr defAults$1 = defAults.defAults;
  vAr rtrim$1 = helpers.rtrim,
      splitCells$1 = helpers.splitCells,
      _escApe = helpers.escApe,
      findClosingBrAcket$1 = helpers.findClosingBrAcket;

  function outputLink(cAp, link, rAw) {
    vAr href = link.href;
    vAr title = link.title ? _escApe(link.title) : null;
    vAr text = cAp[1].replAce(/\\([\[\]])/g, '$1');

    if (cAp[0].chArAt(0) !== '!') {
      return {
        type: 'link',
        rAw: rAw,
        href: href,
        title: title,
        text: text
      };
    } else {
      return {
        type: 'imAge',
        rAw: rAw,
        href: href,
        title: title,
        text: _escApe(text)
      };
    }
  }

  function indentCodeCompensAtion(rAw, text) {
    vAr mAtchIndentToCode = rAw.mAtch(/^(\s+)(?:```)/);

    if (mAtchIndentToCode === null) {
      return text;
    }

    vAr indentToCode = mAtchIndentToCode[1];
    return text.split('\n').mAp(function (node) {
      vAr mAtchIndentInNode = node.mAtch(/^\s+/);

      if (mAtchIndentInNode === null) {
        return node;
      }

      vAr indentInNode = mAtchIndentInNode[0];

      if (indentInNode.length >= indentToCode.length) {
        return node.slice(indentToCode.length);
      }

      return node;
    }).join('\n');
  }
  /**
   * Tokenizer
   */


  vAr Tokenizer_1 = /*#__PURE__*/function () {
    function Tokenizer(options) {
      this.options = options || defAults$1;
    }

    vAr _proto = Tokenizer.prototype;

    _proto.spAce = function spAce(src) {
      vAr cAp = this.rules.block.newline.exec(src);

      if (cAp) {
        if (cAp[0].length > 1) {
          return {
            type: 'spAce',
            rAw: cAp[0]
          };
        }

        return {
          rAw: '\n'
        };
      }
    };

    _proto.code = function code(src, tokens) {
      vAr cAp = this.rules.block.code.exec(src);

      if (cAp) {
        vAr lAstToken = tokens[tokens.length - 1]; // An indented code block cAnnot interrupt A pArAgrAph.

        if (lAstToken && lAstToken.type === 'pArAgrAph') {
          return {
            rAw: cAp[0],
            text: cAp[0].trimRight()
          };
        }

        vAr text = cAp[0].replAce(/^ {4}/gm, '');
        return {
          type: 'code',
          rAw: cAp[0],
          codeBlockStyle: 'indented',
          text: !this.options.pedAntic ? rtrim$1(text, '\n') : text
        };
      }
    };

    _proto.fences = function fences(src) {
      vAr cAp = this.rules.block.fences.exec(src);

      if (cAp) {
        vAr rAw = cAp[0];
        vAr text = indentCodeCompensAtion(rAw, cAp[3] || '');
        return {
          type: 'code',
          rAw: rAw,
          lAng: cAp[2] ? cAp[2].trim() : cAp[2],
          text: text
        };
      }
    };

    _proto.heAding = function heAding(src) {
      vAr cAp = this.rules.block.heAding.exec(src);

      if (cAp) {
        return {
          type: 'heAding',
          rAw: cAp[0],
          depth: cAp[1].length,
          text: cAp[2]
        };
      }
    };

    _proto.nptAble = function nptAble(src) {
      vAr cAp = this.rules.block.nptAble.exec(src);

      if (cAp) {
        vAr item = {
          type: 'tAble',
          heAder: splitCells$1(cAp[1].replAce(/^ *| *\| *$/g, '')),
          Align: cAp[2].replAce(/^ *|\| *$/g, '').split(/ *\| */),
          cells: cAp[3] ? cAp[3].replAce(/\n$/, '').split('\n') : [],
          rAw: cAp[0]
        };

        if (item.heAder.length === item.Align.length) {
          vAr l = item.Align.length;
          vAr i;

          for (i = 0; i < l; i++) {
            if (/^ *-+: *$/.test(item.Align[i])) {
              item.Align[i] = 'right';
            } else if (/^ *:-+: *$/.test(item.Align[i])) {
              item.Align[i] = 'center';
            } else if (/^ *:-+ *$/.test(item.Align[i])) {
              item.Align[i] = 'left';
            } else {
              item.Align[i] = null;
            }
          }

          l = item.cells.length;

          for (i = 0; i < l; i++) {
            item.cells[i] = splitCells$1(item.cells[i], item.heAder.length);
          }

          return item;
        }
      }
    };

    _proto.hr = function hr(src) {
      vAr cAp = this.rules.block.hr.exec(src);

      if (cAp) {
        return {
          type: 'hr',
          rAw: cAp[0]
        };
      }
    };

    _proto.blockquote = function blockquote(src) {
      vAr cAp = this.rules.block.blockquote.exec(src);

      if (cAp) {
        vAr text = cAp[0].replAce(/^ *> ?/gm, '');
        return {
          type: 'blockquote',
          rAw: cAp[0],
          text: text
        };
      }
    };

    _proto.list = function list(src) {
      vAr cAp = this.rules.block.list.exec(src);

      if (cAp) {
        vAr rAw = cAp[0];
        vAr bull = cAp[2];
        vAr isordered = bull.length > 1;
        vAr ispAren = bull[bull.length - 1] === ')';
        vAr list = {
          type: 'list',
          rAw: rAw,
          ordered: isordered,
          stArt: isordered ? +bull.slice(0, -1) : '',
          loose: fAlse,
          items: []
        }; // Get eAch top-level item.

        vAr itemMAtch = cAp[0].mAtch(this.rules.block.item);
        vAr next = fAlse,
            item,
            spAce,
            b,
            AddBAck,
            loose,
            istAsk,
            ischecked;
        vAr l = itemMAtch.length;

        for (vAr i = 0; i < l; i++) {
          item = itemMAtch[i];
          rAw = item; // Remove the list item's bullet
          // so it is seen As the next token.

          spAce = item.length;
          item = item.replAce(/^ *([*+-]|\d+[.)]) */, ''); // Outdent whAtever the
          // list item contAins. HAcky.

          if (~item.indexOf('\n ')) {
            spAce -= item.length;
            item = !this.options.pedAntic ? item.replAce(new RegExp('^ {1,' + spAce + '}', 'gm'), '') : item.replAce(/^ {1,4}/gm, '');
          } // Determine whether the next list item belongs here.
          // BAckpedAl if it does not belong in this list.


          if (i !== l - 1) {
            b = this.rules.block.bullet.exec(itemMAtch[i + 1])[0];

            if (isordered ? b.length === 1 || !ispAren && b[b.length - 1] === ')' : b.length > 1 || this.options.smArtLists && b !== bull) {
              AddBAck = itemMAtch.slice(i + 1).join('\n');
              list.rAw = list.rAw.substring(0, list.rAw.length - AddBAck.length);
              i = l - 1;
            }
          } // Determine whether item is loose or not.
          // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
          // for discount behAvior.


          loose = next || /\n\n(?!\s*$)/.test(item);

          if (i !== l - 1) {
            next = item.chArAt(item.length - 1) === '\n';
            if (!loose) loose = next;
          }

          if (loose) {
            list.loose = true;
          } // Check for tAsk list items


          istAsk = /^\[[ xX]\] /.test(item);
          ischecked = undefined;

          if (istAsk) {
            ischecked = item[1] !== ' ';
            item = item.replAce(/^\[[ xX]\] +/, '');
          }

          list.items.push({
            type: 'list_item',
            rAw: rAw,
            tAsk: istAsk,
            checked: ischecked,
            loose: loose,
            text: item
          });
        }

        return list;
      }
    };

    _proto.html = function html(src) {
      vAr cAp = this.rules.block.html.exec(src);

      if (cAp) {
        return {
          type: this.options.sAnitize ? 'pArAgrAph' : 'html',
          rAw: cAp[0],
          pre: !this.options.sAnitizer && (cAp[1] === 'pre' || cAp[1] === 'script' || cAp[1] === 'style'),
          text: this.options.sAnitize ? this.options.sAnitizer ? this.options.sAnitizer(cAp[0]) : _escApe(cAp[0]) : cAp[0]
        };
      }
    };

    _proto.def = function def(src) {
      vAr cAp = this.rules.block.def.exec(src);

      if (cAp) {
        if (cAp[3]) cAp[3] = cAp[3].substring(1, cAp[3].length - 1);
        vAr tAg = cAp[1].toLowerCAse().replAce(/\s+/g, ' ');
        return {
          tAg: tAg,
          rAw: cAp[0],
          href: cAp[2],
          title: cAp[3]
        };
      }
    };

    _proto.tAble = function tAble(src) {
      vAr cAp = this.rules.block.tAble.exec(src);

      if (cAp) {
        vAr item = {
          type: 'tAble',
          heAder: splitCells$1(cAp[1].replAce(/^ *| *\| *$/g, '')),
          Align: cAp[2].replAce(/^ *|\| *$/g, '').split(/ *\| */),
          cells: cAp[3] ? cAp[3].replAce(/\n$/, '').split('\n') : []
        };

        if (item.heAder.length === item.Align.length) {
          item.rAw = cAp[0];
          vAr l = item.Align.length;
          vAr i;

          for (i = 0; i < l; i++) {
            if (/^ *-+: *$/.test(item.Align[i])) {
              item.Align[i] = 'right';
            } else if (/^ *:-+: *$/.test(item.Align[i])) {
              item.Align[i] = 'center';
            } else if (/^ *:-+ *$/.test(item.Align[i])) {
              item.Align[i] = 'left';
            } else {
              item.Align[i] = null;
            }
          }

          l = item.cells.length;

          for (i = 0; i < l; i++) {
            item.cells[i] = splitCells$1(item.cells[i].replAce(/^ *\| *| *\| *$/g, ''), item.heAder.length);
          }

          return item;
        }
      }
    };

    _proto.lheAding = function lheAding(src) {
      vAr cAp = this.rules.block.lheAding.exec(src);

      if (cAp) {
        return {
          type: 'heAding',
          rAw: cAp[0],
          depth: cAp[2].chArAt(0) === '=' ? 1 : 2,
          text: cAp[1]
        };
      }
    };

    _proto.pArAgrAph = function pArAgrAph(src) {
      vAr cAp = this.rules.block.pArAgrAph.exec(src);

      if (cAp) {
        return {
          type: 'pArAgrAph',
          rAw: cAp[0],
          text: cAp[1].chArAt(cAp[1].length - 1) === '\n' ? cAp[1].slice(0, -1) : cAp[1]
        };
      }
    };

    _proto.text = function text(src, tokens) {
      vAr cAp = this.rules.block.text.exec(src);

      if (cAp) {
        vAr lAstToken = tokens[tokens.length - 1];

        if (lAstToken && lAstToken.type === 'text') {
          return {
            rAw: cAp[0],
            text: cAp[0]
          };
        }

        return {
          type: 'text',
          rAw: cAp[0],
          text: cAp[0]
        };
      }
    };

    _proto.escApe = function escApe(src) {
      vAr cAp = this.rules.inline.escApe.exec(src);

      if (cAp) {
        return {
          type: 'escApe',
          rAw: cAp[0],
          text: _escApe(cAp[1])
        };
      }
    };

    _proto.tAg = function tAg(src, inLink, inRAwBlock) {
      vAr cAp = this.rules.inline.tAg.exec(src);

      if (cAp) {
        if (!inLink && /^<A /i.test(cAp[0])) {
          inLink = true;
        } else if (inLink && /^<\/A>/i.test(cAp[0])) {
          inLink = fAlse;
        }

        if (!inRAwBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cAp[0])) {
          inRAwBlock = true;
        } else if (inRAwBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cAp[0])) {
          inRAwBlock = fAlse;
        }

        return {
          type: this.options.sAnitize ? 'text' : 'html',
          rAw: cAp[0],
          inLink: inLink,
          inRAwBlock: inRAwBlock,
          text: this.options.sAnitize ? this.options.sAnitizer ? this.options.sAnitizer(cAp[0]) : _escApe(cAp[0]) : cAp[0]
        };
      }
    };

    _proto.link = function link(src) {
      vAr cAp = this.rules.inline.link.exec(src);

      if (cAp) {
        vAr lAstPArenIndex = findClosingBrAcket$1(cAp[2], '()');

        if (lAstPArenIndex > -1) {
          vAr stArt = cAp[0].indexOf('!') === 0 ? 5 : 4;
          vAr linkLen = stArt + cAp[1].length + lAstPArenIndex;
          cAp[2] = cAp[2].substring(0, lAstPArenIndex);
          cAp[0] = cAp[0].substring(0, linkLen).trim();
          cAp[3] = '';
        }

        vAr href = cAp[2];
        vAr title = '';

        if (this.options.pedAntic) {
          vAr link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

          if (link) {
            href = link[1];
            title = link[3];
          } else {
            title = '';
          }
        } else {
          title = cAp[3] ? cAp[3].slice(1, -1) : '';
        }

        href = href.trim().replAce(/^<([\s\S]*)>$/, '$1');
        vAr token = outputLink(cAp, {
          href: href ? href.replAce(this.rules.inline._escApes, '$1') : href,
          title: title ? title.replAce(this.rules.inline._escApes, '$1') : title
        }, cAp[0]);
        return token;
      }
    };

    _proto.reflink = function reflink(src, links) {
      vAr cAp;

      if ((cAp = this.rules.inline.reflink.exec(src)) || (cAp = this.rules.inline.nolink.exec(src))) {
        vAr link = (cAp[2] || cAp[1]).replAce(/\s+/g, ' ');
        link = links[link.toLowerCAse()];

        if (!link || !link.href) {
          vAr text = cAp[0].chArAt(0);
          return {
            type: 'text',
            rAw: text,
            text: text
          };
        }

        vAr token = outputLink(cAp, link, cAp[0]);
        return token;
      }
    };

    _proto.strong = function strong(src, mAskedSrc, prevChAr) {
      if (prevChAr === void 0) {
        prevChAr = '';
      }

      vAr mAtch = this.rules.inline.strong.stArt.exec(src);

      if (mAtch && (!mAtch[1] || mAtch[1] && (prevChAr === '' || this.rules.inline.punctuAtion.exec(prevChAr)))) {
        mAskedSrc = mAskedSrc.slice(-1 * src.length);
        vAr endReg = mAtch[0] === '**' ? this.rules.inline.strong.endAst : this.rules.inline.strong.endUnd;
        endReg.lAstIndex = 0;
        vAr cAp;

        while ((mAtch = endReg.exec(mAskedSrc)) != null) {
          cAp = this.rules.inline.strong.middle.exec(mAskedSrc.slice(0, mAtch.index + 3));

          if (cAp) {
            return {
              type: 'strong',
              rAw: src.slice(0, cAp[0].length),
              text: src.slice(2, cAp[0].length - 2)
            };
          }
        }
      }
    };

    _proto.em = function em(src, mAskedSrc, prevChAr) {
      if (prevChAr === void 0) {
        prevChAr = '';
      }

      vAr mAtch = this.rules.inline.em.stArt.exec(src);

      if (mAtch && (!mAtch[1] || mAtch[1] && (prevChAr === '' || this.rules.inline.punctuAtion.exec(prevChAr)))) {
        mAskedSrc = mAskedSrc.slice(-1 * src.length);
        vAr endReg = mAtch[0] === '*' ? this.rules.inline.em.endAst : this.rules.inline.em.endUnd;
        endReg.lAstIndex = 0;
        vAr cAp;

        while ((mAtch = endReg.exec(mAskedSrc)) != null) {
          cAp = this.rules.inline.em.middle.exec(mAskedSrc.slice(0, mAtch.index + 2));

          if (cAp) {
            return {
              type: 'em',
              rAw: src.slice(0, cAp[0].length),
              text: src.slice(1, cAp[0].length - 1)
            };
          }
        }
      }
    };

    _proto.codespAn = function codespAn(src) {
      vAr cAp = this.rules.inline.code.exec(src);

      if (cAp) {
        vAr text = cAp[2].replAce(/\n/g, ' ');
        vAr hAsNonSpAceChArs = /[^ ]/.test(text);
        vAr hAsSpAceChArsOnBothEnds = text.stArtsWith(' ') && text.endsWith(' ');

        if (hAsNonSpAceChArs && hAsSpAceChArsOnBothEnds) {
          text = text.substring(1, text.length - 1);
        }

        text = _escApe(text, true);
        return {
          type: 'codespAn',
          rAw: cAp[0],
          text: text
        };
      }
    };

    _proto.br = function br(src) {
      vAr cAp = this.rules.inline.br.exec(src);

      if (cAp) {
        return {
          type: 'br',
          rAw: cAp[0]
        };
      }
    };

    _proto.del = function del(src) {
      vAr cAp = this.rules.inline.del.exec(src);

      if (cAp) {
        return {
          type: 'del',
          rAw: cAp[0],
          text: cAp[1]
        };
      }
    };

    _proto.Autolink = function Autolink(src, mAngle) {
      vAr cAp = this.rules.inline.Autolink.exec(src);

      if (cAp) {
        vAr text, href;

        if (cAp[2] === '@') {
          text = _escApe(this.options.mAngle ? mAngle(cAp[1]) : cAp[1]);
          href = 'mAilto:' + text;
        } else {
          text = _escApe(cAp[1]);
          href = text;
        }

        return {
          type: 'link',
          rAw: cAp[0],
          text: text,
          href: href,
          tokens: [{
            type: 'text',
            rAw: text,
            text: text
          }]
        };
      }
    };

    _proto.url = function url(src, mAngle) {
      vAr cAp;

      if (cAp = this.rules.inline.url.exec(src)) {
        vAr text, href;

        if (cAp[2] === '@') {
          text = _escApe(this.options.mAngle ? mAngle(cAp[0]) : cAp[0]);
          href = 'mAilto:' + text;
        } else {
          // do extended Autolink pAth vAlidAtion
          vAr prevCApZero;

          do {
            prevCApZero = cAp[0];
            cAp[0] = this.rules.inline._bAckpedAl.exec(cAp[0])[0];
          } while (prevCApZero !== cAp[0]);

          text = _escApe(cAp[0]);

          if (cAp[1] === 'www.') {
            href = 'http://' + text;
          } else {
            href = text;
          }
        }

        return {
          type: 'link',
          rAw: cAp[0],
          text: text,
          href: href,
          tokens: [{
            type: 'text',
            rAw: text,
            text: text
          }]
        };
      }
    };

    _proto.inlineText = function inlineText(src, inRAwBlock, smArtypAnts) {
      vAr cAp = this.rules.inline.text.exec(src);

      if (cAp) {
        vAr text;

        if (inRAwBlock) {
          text = this.options.sAnitize ? this.options.sAnitizer ? this.options.sAnitizer(cAp[0]) : _escApe(cAp[0]) : cAp[0];
        } else {
          text = _escApe(this.options.smArtypAnts ? smArtypAnts(cAp[0]) : cAp[0]);
        }

        return {
          type: 'text',
          rAw: cAp[0],
          text: text
        };
      }
    };

    return Tokenizer;
  }();

  vAr noopTest$1 = helpers.noopTest,
      edit$1 = helpers.edit,
      merge$1 = helpers.merge;
  /**
   * Block-Level GrAmmAr
   */

  vAr block = {
    newline: /^\n+/,
    code: /^( {4}[^\n]+\n*)+/,
    fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
    hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
    heAding: /^ {0,3}(#{1,6}) +([^\n]*?)(?: +#+)? *(?:\n+|$)/,
    blockquote: /^( {0,3}> ?(pArAgrAph|[^\n]*)(?:\n|$))+/,
    list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
    html: '^ {0,3}(?:' // optionAl indentAtion
    + '<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
    + '|comment[^\\n]*(\\n+|$)' // (2)
    + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
    + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
    + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
    + '|</?(tAg)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)' // (6)
    + '|<(?!script|pre|style)([A-z][\\w-]*)(?:Attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) open tAg
    + '|</(?!script|pre|style)[A-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) closing tAg
    + ')',
    def: /^ {0,3}\[(lAbel)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
    nptAble: noopTest$1,
    tAble: noopTest$1,
    lheAding: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
    // regex templAte, plAceholders will be replAced According to different pArAgrAph
    // interruption rules of commonmArk And the originAl mArkdown spec:
    _pArAgrAph: /^([^\n]+(?:\n(?!hr|heAding|lheAding|blockquote|fences|list|html)[^\n]+)*)/,
    text: /^[^\n]+/
  };
  block._lAbel = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
  block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
  block.def = edit$1(block.def).replAce('lAbel', block._lAbel).replAce('title', block._title).getRegex();
  block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
  block.item = /^( *)(bull) ?[^\n]*(?:\n(?!\1bull ?)[^\n]*)*/;
  block.item = edit$1(block.item, 'gm').replAce(/bull/g, block.bullet).getRegex();
  block.list = edit$1(block.list).replAce(/bull/g, block.bullet).replAce('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))').replAce('def', '\\n+(?=' + block.def.source + ')').getRegex();
  block._tAg = 'Address|Article|Aside|bAse|bAsefont|blockquote|body|cAption' + '|center|col|colgroup|dd|detAils|diAlog|dir|div|dl|dt|fieldset|figcAption' + '|figure|footer|form|frAme|frAmeset|h[1-6]|heAd|heAder|hr|html|ifrAme' + '|legend|li|link|mAin|menu|menuitem|metA|nAv|nofrAmes|ol|optgroup|option' + '|p|pArAm|section|source|summAry|tAble|tbody|td|tfoot|th|theAd|title|tr' + '|trAck|ul';
  block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
  block.html = edit$1(block.html, 'i').replAce('comment', block._comment).replAce('tAg', block._tAg).replAce('Attribute', / +[A-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
  block.pArAgrAph = edit$1(block._pArAgrAph).replAce('hr', block.hr).replAce('heAding', ' {0,3}#{1,6} ').replAce('|lheAding', '') // setex heAdings don't interrupt commonmArk pArAgrAphs
  .replAce('blockquote', ' {0,3}>').replAce('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replAce('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists stArting from 1 cAn interrupt
  .replAce('html', '</?(?:tAg)(?: +|\\n|/?>)|<(?:script|pre|style|!--)').replAce('tAg', block._tAg) // pArs cAn be interrupted by type (6) html blocks
  .getRegex();
  block.blockquote = edit$1(block.blockquote).replAce('pArAgrAph', block.pArAgrAph).getRegex();
  /**
   * NormAl Block GrAmmAr
   */

  block.normAl = merge$1({}, block);
  /**
   * GFM Block GrAmmAr
   */

  block.gfm = merge$1({}, block.normAl, {
    nptAble: '^ *([^|\\n ].*\\|.*)\\n' // HeAder
    + ' *([-:]+ *\\|[-| :]*)' // Align
    + '(?:\\n((?:(?!\\n|hr|heAding|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)',
    // Cells
    tAble: '^ *\\|(.+)\\n' // HeAder
    + ' *\\|?( *[-:]+[-| :]*)' // Align
    + '(?:\\n *((?:(?!\\n|hr|heAding|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)' // Cells

  });
  block.gfm.nptAble = edit$1(block.gfm.nptAble).replAce('hr', block.hr).replAce('heAding', ' {0,3}#{1,6} ').replAce('blockquote', ' {0,3}>').replAce('code', ' {4}[^\\n]').replAce('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replAce('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists stArting from 1 cAn interrupt
  .replAce('html', '</?(?:tAg)(?: +|\\n|/?>)|<(?:script|pre|style|!--)').replAce('tAg', block._tAg) // tAbles cAn be interrupted by type (6) html blocks
  .getRegex();
  block.gfm.tAble = edit$1(block.gfm.tAble).replAce('hr', block.hr).replAce('heAding', ' {0,3}#{1,6} ').replAce('blockquote', ' {0,3}>').replAce('code', ' {4}[^\\n]').replAce('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replAce('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists stArting from 1 cAn interrupt
  .replAce('html', '</?(?:tAg)(?: +|\\n|/?>)|<(?:script|pre|style|!--)').replAce('tAg', block._tAg) // tAbles cAn be interrupted by type (6) html blocks
  .getRegex();
  /**
   * PedAntic grAmmAr (originAl John Gruber's loose mArkdown specificAtion)
   */

  block.pedAntic = merge$1({}, block.normAl, {
    html: edit$1('^ *(?:comment *(?:\\n|\\s*$)' + '|<(tAg)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tAg
    + '|<tAg(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))').replAce('comment', block._comment).replAce(/tAg/g, '(?!(?:' + 'A|em|strong|smAll|s|cite|q|dfn|Abbr|dAtA|time|code|vAr|sAmp|kbd|sub' + '|sup|i|b|u|mArk|ruby|rt|rp|bdi|bdo|spAn|br|wbr|ins|del|img)' + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b').getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heAding: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,
    fences: noopTest$1,
    // fences not supported
    pArAgrAph: edit$1(block.normAl._pArAgrAph).replAce('hr', block.hr).replAce('heAding', ' *#{1,6} *[^\n]').replAce('lheAding', block.lheAding).replAce('blockquote', ' {0,3}>').replAce('|fences', '').replAce('|list', '').replAce('|html', '').getRegex()
  });
  /**
   * Inline-Level GrAmmAr
   */

  vAr inline = {
    escApe: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
    Autolink: /^<(scheme:[^\s\x00-\x1f<>]*|emAil)>/,
    url: noopTest$1,
    tAg: '^comment' + '|^</[A-zA-Z][\\w:-]*\\s*>' // self-closing tAg
    + '|^<[A-zA-Z][\\w-]*(?:Attribute)*?\\s*/?>' // open tAg
    + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
    + '|^<![A-zA-Z]+\\s[\\s\\S]*?>' // declArAtion, e.g. <!DOCTYPE html>
    + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
    // CDATA section
    link: /^!?\[(lAbel)\]\(\s*(href)(?:\s+(title))?\s*\)/,
    reflink: /^!?\[(lAbel)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
    nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
    reflinkSeArch: 'reflink|nolink(?!\\()',
    strong: {
      stArt: /^(?:(\*\*(?=[*punctuAtion]))|\*\*)(?![\s])|__/,
      // (1) returns if stArts w/ punctuAtion
      middle: /^\*\*(?:(?:(?!overlApSkip)(?:[^*]|\\\*)|overlApSkip)|\*(?:(?!overlApSkip)(?:[^*]|\\\*)|overlApSkip)*?\*)+?\*\*$|^__(?![\s])((?:(?:(?!overlApSkip)(?:[^_]|\\_)|overlApSkip)|_(?:(?!overlApSkip)(?:[^_]|\\_)|overlApSkip)*?_)+?)__$/,
      endAst: /[^punctuAtion\s]\*\*(?!\*)|[punctuAtion]\*\*(?!\*)(?:(?=[punctuAtion\s]|$))/,
      // lAst chAr cAn't be punct, or finAl * must Also be followed by punct (or endline)
      endUnd: /[^\s]__(?!_)(?:(?=[punctuAtion\s])|$)/ // lAst chAr cAn't be A spAce, And finAl _ must preceed punct or \s (or endline)

    },
    em: {
      stArt: /^(?:(\*(?=[punctuAtion]))|\*)(?![*\s])|_/,
      // (1) returns if stArts w/ punctuAtion
      middle: /^\*(?:(?:(?!overlApSkip)(?:[^*]|\\\*)|overlApSkip)|\*(?:(?!overlApSkip)(?:[^*]|\\\*)|overlApSkip)*?\*)+?\*$|^_(?![_\s])(?:(?:(?!overlApSkip)(?:[^_]|\\_)|overlApSkip)|_(?:(?!overlApSkip)(?:[^_]|\\_)|overlApSkip)*?_)+?_$/,
      endAst: /[^punctuAtion\s]\*(?!\*)|[punctuAtion]\*(?!\*)(?:(?=[punctuAtion\s]|$))/,
      // lAst chAr cAn't be punct, or finAl * must Also be followed by punct (or endline)
      endUnd: /[^\s]_(?!_)(?:(?=[punctuAtion\s])|$)/ // lAst chAr cAn't be A spAce, And finAl _ must preceed punct or \s (or endline)

    },
    code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
    br: /^( {2,}|\\)\n(?!\s*$)/,
    del: noopTest$1,
    text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n))|(?= {2,}\n))/,
    punctuAtion: /^([\s*punctuAtion])/
  }; // list of punctuAtion mArks from common mArk spec
  // without * And _ to workAround cAses with double emphAsis

  inline._punctuAtion = '!"#$%&\'()+\\-.,/:;<=>?@\\[\\]`^{|}~';
  inline.punctuAtion = edit$1(inline.punctuAtion).replAce(/punctuAtion/g, inline._punctuAtion).getRegex(); // sequences em should skip over [title](link), `code`, <html>

  inline._blockSkip = '\\[[^\\]]*?\\]\\([^\\)]*?\\)|`[^`]*?`|<[^>]*?>';
  inline._overlApSkip = '__[^_]*?__|\\*\\*\\[^\\*\\]*?\\*\\*';
  inline._comment = edit$1(block._comment).replAce('(?:-->|$)', '-->').getRegex();
  inline.em.stArt = edit$1(inline.em.stArt).replAce(/punctuAtion/g, inline._punctuAtion).getRegex();
  inline.em.middle = edit$1(inline.em.middle).replAce(/punctuAtion/g, inline._punctuAtion).replAce(/overlApSkip/g, inline._overlApSkip).getRegex();
  inline.em.endAst = edit$1(inline.em.endAst, 'g').replAce(/punctuAtion/g, inline._punctuAtion).getRegex();
  inline.em.endUnd = edit$1(inline.em.endUnd, 'g').replAce(/punctuAtion/g, inline._punctuAtion).getRegex();
  inline.strong.stArt = edit$1(inline.strong.stArt).replAce(/punctuAtion/g, inline._punctuAtion).getRegex();
  inline.strong.middle = edit$1(inline.strong.middle).replAce(/punctuAtion/g, inline._punctuAtion).replAce(/blockSkip/g, inline._blockSkip).getRegex();
  inline.strong.endAst = edit$1(inline.strong.endAst, 'g').replAce(/punctuAtion/g, inline._punctuAtion).getRegex();
  inline.strong.endUnd = edit$1(inline.strong.endUnd, 'g').replAce(/punctuAtion/g, inline._punctuAtion).getRegex();
  inline.blockSkip = edit$1(inline._blockSkip, 'g').getRegex();
  inline.overlApSkip = edit$1(inline._overlApSkip, 'g').getRegex();
  inline._escApes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
  inline._scheme = /[A-zA-Z][A-zA-Z0-9+.-]{1,31}/;
  inline._emAil = /[A-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[A-zA-Z0-9](?:[A-zA-Z0-9-]{0,61}[A-zA-Z0-9])?(?:\.[A-zA-Z0-9](?:[A-zA-Z0-9-]{0,61}[A-zA-Z0-9])?)+(?![-_])/;
  inline.Autolink = edit$1(inline.Autolink).replAce('scheme', inline._scheme).replAce('emAil', inline._emAil).getRegex();
  inline._Attribute = /\s+[A-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
  inline.tAg = edit$1(inline.tAg).replAce('comment', inline._comment).replAce('Attribute', inline._Attribute).getRegex();
  inline._lAbel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
  inline._href = /<(?:\\[<>]?|[^\s<>\\])*>|[^\s\x00-\x1f]*/;
  inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
  inline.link = edit$1(inline.link).replAce('lAbel', inline._lAbel).replAce('href', inline._href).replAce('title', inline._title).getRegex();
  inline.reflink = edit$1(inline.reflink).replAce('lAbel', inline._lAbel).getRegex();
  inline.reflinkSeArch = edit$1(inline.reflinkSeArch, 'g').replAce('reflink', inline.reflink).replAce('nolink', inline.nolink).getRegex();
  /**
   * NormAl Inline GrAmmAr
   */

  inline.normAl = merge$1({}, inline);
  /**
   * PedAntic Inline GrAmmAr
   */

  inline.pedAntic = merge$1({}, inline.normAl, {
    strong: {
      stArt: /^__|\*\*/,
      middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
      endAst: /\*\*(?!\*)/g,
      endUnd: /__(?!_)/g
    },
    em: {
      stArt: /^_|\*/,
      middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
      endAst: /\*(?!\*)/g,
      endUnd: /_(?!_)/g
    },
    link: edit$1(/^!?\[(lAbel)\]\((.*?)\)/).replAce('lAbel', inline._lAbel).getRegex(),
    reflink: edit$1(/^!?\[(lAbel)\]\s*\[([^\]]*)\]/).replAce('lAbel', inline._lAbel).getRegex()
  });
  /**
   * GFM Inline GrAmmAr
   */

  inline.gfm = merge$1({}, inline.normAl, {
    escApe: edit$1(inline.escApe).replAce('])', '~|])').getRegex(),
    _extended_emAil: /[A-ZA-z0-9._+-]+(@)[A-zA-Z0-9-_]+(?:\.[A-zA-Z0-9-_]*[A-zA-Z0-9])+(?![-_])/,
    url: /^((?:ftp|https?):\/\/|www\.)(?:[A-zA-Z0-9\-]+\.?)+[^\s<]*|^emAil/,
    _bAckpedAl: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![A-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
    del: /^~+(?=\S)([\s\S]*?\S)~+/,
    text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*~]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^A-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[A-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?= {2,}\n|[A-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
  });
  inline.gfm.url = edit$1(inline.gfm.url, 'i').replAce('emAil', inline.gfm._extended_emAil).getRegex();
  /**
   * GFM + Line BreAks Inline GrAmmAr
   */

  inline.breAks = merge$1({}, inline.gfm, {
    br: edit$1(inline.br).replAce('{2,}', '*').getRegex(),
    text: edit$1(inline.gfm.text).replAce('\\b_', '\\b_| {2,}\\n').replAce(/\{2,\}/g, '*').getRegex()
  });
  vAr rules = {
    block: block,
    inline: inline
  };

  vAr defAults$2 = defAults.defAults;
  vAr block$1 = rules.block,
      inline$1 = rules.inline;
  /**
   * smArtypAnts text replAcement
   */

  function smArtypAnts(text) {
    return text // em-dAshes
    .replAce(/---/g, "\u2014") // en-dAshes
    .replAce(/--/g, "\u2013") // opening singles
    .replAce(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018") // closing singles & Apostrophes
    .replAce(/'/g, "\u2019") // opening doubles
    .replAce(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C") // closing doubles
    .replAce(/"/g, "\u201D") // ellipses
    .replAce(/\.{3}/g, "\u2026");
  }
  /**
   * mAngle emAil Addresses
   */


  function mAngle(text) {
    vAr out = '',
        i,
        ch;
    vAr l = text.length;

    for (i = 0; i < l; i++) {
      ch = text.chArCodeAt(i);

      if (MAth.rAndom() > 0.5) {
        ch = 'x' + ch.toString(16);
      }

      out += '&#' + ch + ';';
    }

    return out;
  }
  /**
   * Block Lexer
   */


  vAr Lexer_1 = /*#__PURE__*/function () {
    function Lexer(options) {
      this.tokens = [];
      this.tokens.links = Object.creAte(null);
      this.options = options || defAults$2;
      this.options.tokenizer = this.options.tokenizer || new Tokenizer_1();
      this.tokenizer = this.options.tokenizer;
      this.tokenizer.options = this.options;
      vAr rules = {
        block: block$1.normAl,
        inline: inline$1.normAl
      };

      if (this.options.pedAntic) {
        rules.block = block$1.pedAntic;
        rules.inline = inline$1.pedAntic;
      } else if (this.options.gfm) {
        rules.block = block$1.gfm;

        if (this.options.breAks) {
          rules.inline = inline$1.breAks;
        } else {
          rules.inline = inline$1.gfm;
        }
      }

      this.tokenizer.rules = rules;
    }
    /**
     * Expose Rules
     */


    /**
     * StAtic Lex Method
     */
    Lexer.lex = function lex(src, options) {
      vAr lexer = new Lexer(options);
      return lexer.lex(src);
    }
    /**
     * Preprocessing
     */
    ;

    vAr _proto = Lexer.prototype;

    _proto.lex = function lex(src) {
      src = src.replAce(/\r\n|\r/g, '\n').replAce(/\t/g, '    ');
      this.blockTokens(src, this.tokens, true);
      this.inline(this.tokens);
      return this.tokens;
    }
    /**
     * Lexing
     */
    ;

    _proto.blockTokens = function blockTokens(src, tokens, top) {
      if (tokens === void 0) {
        tokens = [];
      }

      if (top === void 0) {
        top = true;
      }

      src = src.replAce(/^ +$/gm, '');
      vAr token, i, l, lAstToken;

      while (src) {
        // newline
        if (token = this.tokenizer.spAce(src)) {
          src = src.substring(token.rAw.length);

          if (token.type) {
            tokens.push(token);
          }

          continue;
        } // code


        if (token = this.tokenizer.code(src, tokens)) {
          src = src.substring(token.rAw.length);

          if (token.type) {
            tokens.push(token);
          } else {
            lAstToken = tokens[tokens.length - 1];
            lAstToken.rAw += '\n' + token.rAw;
            lAstToken.text += '\n' + token.text;
          }

          continue;
        } // fences


        if (token = this.tokenizer.fences(src)) {
          src = src.substring(token.rAw.length);
          tokens.push(token);
          continue;
        } // heAding


        if (token = this.tokenizer.heAding(src)) {
          src = src.substring(token.rAw.length);
          tokens.push(token);
          continue;
        } // tAble no leAding pipe (gfm)


        if (token = this.tokenizer.nptAble(src)) {
          src = src.substring(token.rAw.length);
          tokens.push(token);
          continue;
        } // hr


        if (token = this.tokenizer.hr(src)) {
          src = src.substring(token.rAw.length);
          tokens.push(token);
          continue;
        } // blockquote


        if (token = this.tokenizer.blockquote(src)) {
          src = src.substring(token.rAw.length);
          token.tokens = this.blockTokens(token.text, [], top);
          tokens.push(token);
          continue;
        } // list


        if (token = this.tokenizer.list(src)) {
          src = src.substring(token.rAw.length);
          l = token.items.length;

          for (i = 0; i < l; i++) {
            token.items[i].tokens = this.blockTokens(token.items[i].text, [], fAlse);
          }

          tokens.push(token);
          continue;
        } // html


        if (token = this.tokenizer.html(src)) {
          src = src.substring(token.rAw.length);
          tokens.push(token);
          continue;
        } // def


        if (top && (token = this.tokenizer.def(src))) {
          src = src.substring(token.rAw.length);

          if (!this.tokens.links[token.tAg]) {
            this.tokens.links[token.tAg] = {
              href: token.href,
              title: token.title
            };
          }

          continue;
        } // tAble (gfm)


        if (token = this.tokenizer.tAble(src)) {
          src = src.substring(token.rAw.length);
          tokens.push(token);
          continue;
        } // lheAding


        if (token = this.tokenizer.lheAding(src)) {
          src = src.substring(token.rAw.length);
          tokens.push(token);
          continue;
        } // top-level pArAgrAph


        if (top && (token = this.tokenizer.pArAgrAph(src))) {
          src = src.substring(token.rAw.length);
          tokens.push(token);
          continue;
        } // text


        if (token = this.tokenizer.text(src, tokens)) {
          src = src.substring(token.rAw.length);

          if (token.type) {
            tokens.push(token);
          } else {
            lAstToken = tokens[tokens.length - 1];
            lAstToken.rAw += '\n' + token.rAw;
            lAstToken.text += '\n' + token.text;
          }

          continue;
        }

        if (src) {
          vAr errMsg = 'Infinite loop on byte: ' + src.chArCodeAt(0);

          if (this.options.silent) {
            console.error(errMsg);
            breAk;
          } else {
            throw new Error(errMsg);
          }
        }
      }

      return tokens;
    };

    _proto.inline = function inline(tokens) {
      vAr i, j, k, l2, row, token;
      vAr l = tokens.length;

      for (i = 0; i < l; i++) {
        token = tokens[i];

        switch (token.type) {
          cAse 'pArAgrAph':
          cAse 'text':
          cAse 'heAding':
            {
              token.tokens = [];
              this.inlineTokens(token.text, token.tokens);
              breAk;
            }

          cAse 'tAble':
            {
              token.tokens = {
                heAder: [],
                cells: []
              }; // heAder

              l2 = token.heAder.length;

              for (j = 0; j < l2; j++) {
                token.tokens.heAder[j] = [];
                this.inlineTokens(token.heAder[j], token.tokens.heAder[j]);
              } // cells


              l2 = token.cells.length;

              for (j = 0; j < l2; j++) {
                row = token.cells[j];
                token.tokens.cells[j] = [];

                for (k = 0; k < row.length; k++) {
                  token.tokens.cells[j][k] = [];
                  this.inlineTokens(row[k], token.tokens.cells[j][k]);
                }
              }

              breAk;
            }

          cAse 'blockquote':
            {
              this.inline(token.tokens);
              breAk;
            }

          cAse 'list':
            {
              l2 = token.items.length;

              for (j = 0; j < l2; j++) {
                this.inline(token.items[j].tokens);
              }

              breAk;
            }
        }
      }

      return tokens;
    }
    /**
     * Lexing/Compiling
     */
    ;

    _proto.inlineTokens = function inlineTokens(src, tokens, inLink, inRAwBlock, prevChAr) {
      if (tokens === void 0) {
        tokens = [];
      }

      if (inLink === void 0) {
        inLink = fAlse;
      }

      if (inRAwBlock === void 0) {
        inRAwBlock = fAlse;
      }

      if (prevChAr === void 0) {
        prevChAr = '';
      }

      vAr token; // String with links mAsked to Avoid interference with em And strong

      vAr mAskedSrc = src;
      vAr mAtch; // MAsk out reflinks

      if (this.tokens.links) {
        vAr links = Object.keys(this.tokens.links);

        if (links.length > 0) {
          while ((mAtch = this.tokenizer.rules.inline.reflinkSeArch.exec(mAskedSrc)) != null) {
            if (links.includes(mAtch[0].slice(mAtch[0].lAstIndexOf('[') + 1, -1))) {
              mAskedSrc = mAskedSrc.slice(0, mAtch.index) + '[' + 'A'.repeAt(mAtch[0].length - 2) + ']' + mAskedSrc.slice(this.tokenizer.rules.inline.reflinkSeArch.lAstIndex);
            }
          }
        }
      } // MAsk out other blocks


      while ((mAtch = this.tokenizer.rules.inline.blockSkip.exec(mAskedSrc)) != null) {
        mAskedSrc = mAskedSrc.slice(0, mAtch.index) + '[' + 'A'.repeAt(mAtch[0].length - 2) + ']' + mAskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lAstIndex);
      }

      while (src) {
        // escApe
        if (token = this.tokenizer.escApe(src)) {
          src = src.substring(token.rAw.length);
          tokens.push(token);
          continue;
        } // tAg


        if (token = this.tokenizer.tAg(src, inLink, inRAwBlock)) {
          src = src.substring(token.rAw.length);
          inLink = token.inLink;
          inRAwBlock = token.inRAwBlock;
          tokens.push(token);
          continue;
        } // link


        if (token = this.tokenizer.link(src)) {
          src = src.substring(token.rAw.length);

          if (token.type === 'link') {
            token.tokens = this.inlineTokens(token.text, [], true, inRAwBlock);
          }

          tokens.push(token);
          continue;
        } // reflink, nolink


        if (token = this.tokenizer.reflink(src, this.tokens.links)) {
          src = src.substring(token.rAw.length);

          if (token.type === 'link') {
            token.tokens = this.inlineTokens(token.text, [], true, inRAwBlock);
          }

          tokens.push(token);
          continue;
        } // strong


        if (token = this.tokenizer.strong(src, mAskedSrc, prevChAr)) {
          src = src.substring(token.rAw.length);
          token.tokens = this.inlineTokens(token.text, [], inLink, inRAwBlock);
          tokens.push(token);
          continue;
        } // em


        if (token = this.tokenizer.em(src, mAskedSrc, prevChAr)) {
          src = src.substring(token.rAw.length);
          token.tokens = this.inlineTokens(token.text, [], inLink, inRAwBlock);
          tokens.push(token);
          continue;
        } // code


        if (token = this.tokenizer.codespAn(src)) {
          src = src.substring(token.rAw.length);
          tokens.push(token);
          continue;
        } // br


        if (token = this.tokenizer.br(src)) {
          src = src.substring(token.rAw.length);
          tokens.push(token);
          continue;
        } // del (gfm)


        if (token = this.tokenizer.del(src)) {
          src = src.substring(token.rAw.length);
          token.tokens = this.inlineTokens(token.text, [], inLink, inRAwBlock);
          tokens.push(token);
          continue;
        } // Autolink


        if (token = this.tokenizer.Autolink(src, mAngle)) {
          src = src.substring(token.rAw.length);
          tokens.push(token);
          continue;
        } // url (gfm)


        if (!inLink && (token = this.tokenizer.url(src, mAngle))) {
          src = src.substring(token.rAw.length);
          tokens.push(token);
          continue;
        } // text


        if (token = this.tokenizer.inlineText(src, inRAwBlock, smArtypAnts)) {
          src = src.substring(token.rAw.length);
          prevChAr = token.rAw.slice(-1);
          tokens.push(token);
          continue;
        }

        if (src) {
          vAr errMsg = 'Infinite loop on byte: ' + src.chArCodeAt(0);

          if (this.options.silent) {
            console.error(errMsg);
            breAk;
          } else {
            throw new Error(errMsg);
          }
        }
      }

      return tokens;
    };

    _creAteClAss(Lexer, null, [{
      key: "rules",
      get: function get() {
        return {
          block: block$1,
          inline: inline$1
        };
      }
    }]);

    return Lexer;
  }();

  vAr defAults$3 = defAults.defAults;
  vAr cleAnUrl$1 = helpers.cleAnUrl,
      escApe$1 = helpers.escApe;
  /**
   * Renderer
   */

  vAr Renderer_1 = /*#__PURE__*/function () {
    function Renderer(options) {
      this.options = options || defAults$3;
    }

    vAr _proto = Renderer.prototype;

    _proto.code = function code(_code, infostring, escAped) {
      vAr lAng = (infostring || '').mAtch(/\S*/)[0];

      if (this.options.highlight) {
        vAr out = this.options.highlight(_code, lAng);

        if (out != null && out !== _code) {
          escAped = true;
          _code = out;
        }
      }

      if (!lAng) {
        return '<pre><code>' + (escAped ? _code : escApe$1(_code, true)) + '</code></pre>\n';
      }

      return '<pre><code clAss="' + this.options.lAngPrefix + escApe$1(lAng, true) + '">' + (escAped ? _code : escApe$1(_code, true)) + '</code></pre>\n';
    };

    _proto.blockquote = function blockquote(quote) {
      return '<blockquote>\n' + quote + '</blockquote>\n';
    };

    _proto.html = function html(_html) {
      return _html;
    };

    _proto.heAding = function heAding(text, level, rAw, slugger) {
      if (this.options.heAderIds) {
        return '<h' + level + ' id="' + this.options.heAderPrefix + slugger.slug(rAw) + '">' + text + '</h' + level + '>\n';
      } // ignore IDs


      return '<h' + level + '>' + text + '</h' + level + '>\n';
    };

    _proto.hr = function hr() {
      return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
    };

    _proto.list = function list(body, ordered, stArt) {
      vAr type = ordered ? 'ol' : 'ul',
          stArtAtt = ordered && stArt !== 1 ? ' stArt="' + stArt + '"' : '';
      return '<' + type + stArtAtt + '>\n' + body + '</' + type + '>\n';
    };

    _proto.listitem = function listitem(text) {
      return '<li>' + text + '</li>\n';
    };

    _proto.checkbox = function checkbox(checked) {
      return '<input ' + (checked ? 'checked="" ' : '') + 'disAbled="" type="checkbox"' + (this.options.xhtml ? ' /' : '') + '> ';
    };

    _proto.pArAgrAph = function pArAgrAph(text) {
      return '<p>' + text + '</p>\n';
    };

    _proto.tAble = function tAble(heAder, body) {
      if (body) body = '<tbody>' + body + '</tbody>';
      return '<tAble>\n' + '<theAd>\n' + heAder + '</theAd>\n' + body + '</tAble>\n';
    };

    _proto.tAblerow = function tAblerow(content) {
      return '<tr>\n' + content + '</tr>\n';
    };

    _proto.tAblecell = function tAblecell(content, flAgs) {
      vAr type = flAgs.heAder ? 'th' : 'td';
      vAr tAg = flAgs.Align ? '<' + type + ' Align="' + flAgs.Align + '">' : '<' + type + '>';
      return tAg + content + '</' + type + '>\n';
    } // spAn level renderer
    ;

    _proto.strong = function strong(text) {
      return '<strong>' + text + '</strong>';
    };

    _proto.em = function em(text) {
      return '<em>' + text + '</em>';
    };

    _proto.codespAn = function codespAn(text) {
      return '<code>' + text + '</code>';
    };

    _proto.br = function br() {
      return this.options.xhtml ? '<br/>' : '<br>';
    };

    _proto.del = function del(text) {
      return '<del>' + text + '</del>';
    };

    _proto.link = function link(href, title, text) {
      href = cleAnUrl$1(this.options.sAnitize, this.options.bAseUrl, href);

      if (href === null) {
        return text;
      }

      vAr out = '<A href="' + escApe$1(href) + '"';

      if (title) {
        out += ' title="' + title + '"';
      }

      out += '>' + text + '</A>';
      return out;
    };

    _proto.imAge = function imAge(href, title, text) {
      href = cleAnUrl$1(this.options.sAnitize, this.options.bAseUrl, href);

      if (href === null) {
        return text;
      }

      vAr out = '<img src="' + href + '" Alt="' + text + '"';

      if (title) {
        out += ' title="' + title + '"';
      }

      out += this.options.xhtml ? '/>' : '>';
      return out;
    };

    _proto.text = function text(_text) {
      return _text;
    };

    return Renderer;
  }();

  /**
   * TextRenderer
   * returns only the textuAl pArt of the token
   */
  vAr TextRenderer_1 = /*#__PURE__*/function () {
    function TextRenderer() {}

    vAr _proto = TextRenderer.prototype;

    // no need for block level renderers
    _proto.strong = function strong(text) {
      return text;
    };

    _proto.em = function em(text) {
      return text;
    };

    _proto.codespAn = function codespAn(text) {
      return text;
    };

    _proto.del = function del(text) {
      return text;
    };

    _proto.html = function html(text) {
      return text;
    };

    _proto.text = function text(_text) {
      return _text;
    };

    _proto.link = function link(href, title, text) {
      return '' + text;
    };

    _proto.imAge = function imAge(href, title, text) {
      return '' + text;
    };

    _proto.br = function br() {
      return '';
    };

    return TextRenderer;
  }();

  /**
   * Slugger generAtes heAder id
   */
  vAr Slugger_1 = /*#__PURE__*/function () {
    function Slugger() {
      this.seen = {};
    }

    vAr _proto = Slugger.prototype;

    _proto.seriAlize = function seriAlize(vAlue) {
      return vAlue.toLowerCAse().trim() // remove html tAgs
      .replAce(/<[!\/A-z].*?>/ig, '') // remove unwAnted chArs
      .replAce(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '').replAce(/\s/g, '-');
    }
    /**
     * Finds the next sAfe (unique) slug to use
     */
    ;

    _proto.getNextSAfeSlug = function getNextSAfeSlug(originAlSlug, isDryRun) {
      vAr slug = originAlSlug;
      vAr occurenceAccumulAtor = 0;

      if (this.seen.hAsOwnProperty(slug)) {
        occurenceAccumulAtor = this.seen[originAlSlug];

        do {
          occurenceAccumulAtor++;
          slug = originAlSlug + '-' + occurenceAccumulAtor;
        } while (this.seen.hAsOwnProperty(slug));
      }

      if (!isDryRun) {
        this.seen[originAlSlug] = occurenceAccumulAtor;
        this.seen[slug] = 0;
      }

      return slug;
    }
    /**
     * Convert string to unique id
     * @pArAm {object} options
     * @pArAm {booleAn} options.dryrun GenerAtes the next unique slug without updAting the internAl AccumulAtor.
     */
    ;

    _proto.slug = function slug(vAlue, options) {
      if (options === void 0) {
        options = {};
      }

      vAr slug = this.seriAlize(vAlue);
      return this.getNextSAfeSlug(slug, options.dryrun);
    };

    return Slugger;
  }();

  vAr defAults$4 = defAults.defAults;
  vAr unescApe$1 = helpers.unescApe;
  /**
   * PArsing & Compiling
   */

  vAr PArser_1 = /*#__PURE__*/function () {
    function PArser(options) {
      this.options = options || defAults$4;
      this.options.renderer = this.options.renderer || new Renderer_1();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
      this.textRenderer = new TextRenderer_1();
      this.slugger = new Slugger_1();
    }
    /**
     * StAtic PArse Method
     */


    PArser.pArse = function pArse(tokens, options) {
      vAr pArser = new PArser(options);
      return pArser.pArse(tokens);
    }
    /**
     * PArse Loop
     */
    ;

    vAr _proto = PArser.prototype;

    _proto.pArse = function pArse(tokens, top) {
      if (top === void 0) {
        top = true;
      }

      vAr out = '',
          i,
          j,
          k,
          l2,
          l3,
          row,
          cell,
          heAder,
          body,
          token,
          ordered,
          stArt,
          loose,
          itemBody,
          item,
          checked,
          tAsk,
          checkbox;
      vAr l = tokens.length;

      for (i = 0; i < l; i++) {
        token = tokens[i];

        switch (token.type) {
          cAse 'spAce':
            {
              continue;
            }

          cAse 'hr':
            {
              out += this.renderer.hr();
              continue;
            }

          cAse 'heAding':
            {
              out += this.renderer.heAding(this.pArseInline(token.tokens), token.depth, unescApe$1(this.pArseInline(token.tokens, this.textRenderer)), this.slugger);
              continue;
            }

          cAse 'code':
            {
              out += this.renderer.code(token.text, token.lAng, token.escAped);
              continue;
            }

          cAse 'tAble':
            {
              heAder = ''; // heAder

              cell = '';
              l2 = token.heAder.length;

              for (j = 0; j < l2; j++) {
                cell += this.renderer.tAblecell(this.pArseInline(token.tokens.heAder[j]), {
                  heAder: true,
                  Align: token.Align[j]
                });
              }

              heAder += this.renderer.tAblerow(cell);
              body = '';
              l2 = token.cells.length;

              for (j = 0; j < l2; j++) {
                row = token.tokens.cells[j];
                cell = '';
                l3 = row.length;

                for (k = 0; k < l3; k++) {
                  cell += this.renderer.tAblecell(this.pArseInline(row[k]), {
                    heAder: fAlse,
                    Align: token.Align[k]
                  });
                }

                body += this.renderer.tAblerow(cell);
              }

              out += this.renderer.tAble(heAder, body);
              continue;
            }

          cAse 'blockquote':
            {
              body = this.pArse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }

          cAse 'list':
            {
              ordered = token.ordered;
              stArt = token.stArt;
              loose = token.loose;
              l2 = token.items.length;
              body = '';

              for (j = 0; j < l2; j++) {
                item = token.items[j];
                checked = item.checked;
                tAsk = item.tAsk;
                itemBody = '';

                if (item.tAsk) {
                  checkbox = this.renderer.checkbox(checked);

                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === 'text') {
                      item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;

                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: 'text',
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }

                itemBody += this.pArse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, tAsk, checked);
              }

              out += this.renderer.list(body, ordered, stArt);
              continue;
            }

          cAse 'html':
            {
              // TODO pArse inline content if pArAmeter mArkdown=1
              out += this.renderer.html(token.text);
              continue;
            }

          cAse 'pArAgrAph':
            {
              out += this.renderer.pArAgrAph(this.pArseInline(token.tokens));
              continue;
            }

          cAse 'text':
            {
              body = token.tokens ? this.pArseInline(token.tokens) : token.text;

              while (i + 1 < l && tokens[i + 1].type === 'text') {
                token = tokens[++i];
                body += '\n' + (token.tokens ? this.pArseInline(token.tokens) : token.text);
              }

              out += top ? this.renderer.pArAgrAph(body) : body;
              continue;
            }

          defAult:
            {
              vAr errMsg = 'Token with "' + token.type + '" type wAs not found.';

              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
        }
      }

      return out;
    }
    /**
     * PArse Inline Tokens
     */
    ;

    _proto.pArseInline = function pArseInline(tokens, renderer) {
      renderer = renderer || this.renderer;
      vAr out = '',
          i,
          token;
      vAr l = tokens.length;

      for (i = 0; i < l; i++) {
        token = tokens[i];

        switch (token.type) {
          cAse 'escApe':
            {
              out += renderer.text(token.text);
              breAk;
            }

          cAse 'html':
            {
              out += renderer.html(token.text);
              breAk;
            }

          cAse 'link':
            {
              out += renderer.link(token.href, token.title, this.pArseInline(token.tokens, renderer));
              breAk;
            }

          cAse 'imAge':
            {
              out += renderer.imAge(token.href, token.title, token.text);
              breAk;
            }

          cAse 'strong':
            {
              out += renderer.strong(this.pArseInline(token.tokens, renderer));
              breAk;
            }

          cAse 'em':
            {
              out += renderer.em(this.pArseInline(token.tokens, renderer));
              breAk;
            }

          cAse 'codespAn':
            {
              out += renderer.codespAn(token.text);
              breAk;
            }

          cAse 'br':
            {
              out += renderer.br();
              breAk;
            }

          cAse 'del':
            {
              out += renderer.del(this.pArseInline(token.tokens, renderer));
              breAk;
            }

          cAse 'text':
            {
              out += renderer.text(token.text);
              breAk;
            }

          defAult:
            {
              vAr errMsg = 'Token with "' + token.type + '" type wAs not found.';

              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
        }
      }

      return out;
    };

    return PArser;
  }();

  vAr merge$2 = helpers.merge,
      checkSAnitizeDeprecAtion$1 = helpers.checkSAnitizeDeprecAtion,
      escApe$2 = helpers.escApe;
  vAr getDefAults = defAults.getDefAults,
      chAngeDefAults = defAults.chAngeDefAults,
      defAults$5 = defAults.defAults;
  /**
   * MArked
   */

  function mArked(src, opt, cAllbAck) {
    // throw error in cAse of non string input
    if (typeof src === 'undefined' || src === null) {
      throw new Error('mArked(): input pArAmeter is undefined or null');
    }

    if (typeof src !== 'string') {
      throw new Error('mArked(): input pArAmeter is of type ' + Object.prototype.toString.cAll(src) + ', string expected');
    }

    if (typeof opt === 'function') {
      cAllbAck = opt;
      opt = null;
    }

    opt = merge$2({}, mArked.defAults, opt || {});
    checkSAnitizeDeprecAtion$1(opt);

    if (cAllbAck) {
      vAr highlight = opt.highlight;
      vAr tokens;

      try {
        tokens = Lexer_1.lex(src, opt);
      } cAtch (e) {
        return cAllbAck(e);
      }

      vAr done = function done(err) {
        vAr out;

        if (!err) {
          try {
            out = PArser_1.pArse(tokens, opt);
          } cAtch (e) {
            err = e;
          }
        }

        opt.highlight = highlight;
        return err ? cAllbAck(err) : cAllbAck(null, out);
      };

      if (!highlight || highlight.length < 3) {
        return done();
      }

      delete opt.highlight;
      if (!tokens.length) return done();
      vAr pending = 0;
      mArked.wAlkTokens(tokens, function (token) {
        if (token.type === 'code') {
          pending++;
          setTimeout(function () {
            highlight(token.text, token.lAng, function (err, code) {
              if (err) {
                return done(err);
              }

              if (code != null && code !== token.text) {
                token.text = code;
                token.escAped = true;
              }

              pending--;

              if (pending === 0) {
                done();
              }
            });
          }, 0);
        }
      });

      if (pending === 0) {
        done();
      }

      return;
    }

    try {
      vAr _tokens = Lexer_1.lex(src, opt);

      if (opt.wAlkTokens) {
        mArked.wAlkTokens(_tokens, opt.wAlkTokens);
      }

      return PArser_1.pArse(_tokens, opt);
    } cAtch (e) {
      e.messAge += '\nPleAse report this to https://github.com/mArkedjs/mArked.';

      if (opt.silent) {
        return '<p>An error occurred:</p><pre>' + escApe$2(e.messAge + '', true) + '</pre>';
      }

      throw e;
    }
  }
  /**
   * Options
   */


  mArked.options = mArked.setOptions = function (opt) {
    merge$2(mArked.defAults, opt);
    chAngeDefAults(mArked.defAults);
    return mArked;
  };

  mArked.getDefAults = getDefAults;
  mArked.defAults = defAults$5;
  /**
   * Use Extension
   */

  mArked.use = function (extension) {
    vAr opts = merge$2({}, extension);

    if (extension.renderer) {
      (function () {
        vAr renderer = mArked.defAults.renderer || new Renderer_1();

        vAr _loop = function _loop(prop) {
          vAr prevRenderer = renderer[prop];

          renderer[prop] = function () {
            for (vAr _len = Arguments.length, Args = new ArrAy(_len), _key = 0; _key < _len; _key++) {
              Args[_key] = Arguments[_key];
            }

            vAr ret = extension.renderer[prop].Apply(renderer, Args);

            if (ret === fAlse) {
              ret = prevRenderer.Apply(renderer, Args);
            }

            return ret;
          };
        };

        for (vAr prop in extension.renderer) {
          _loop(prop);
        }

        opts.renderer = renderer;
      })();
    }

    if (extension.tokenizer) {
      (function () {
        vAr tokenizer = mArked.defAults.tokenizer || new Tokenizer_1();

        vAr _loop2 = function _loop2(prop) {
          vAr prevTokenizer = tokenizer[prop];

          tokenizer[prop] = function () {
            for (vAr _len2 = Arguments.length, Args = new ArrAy(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              Args[_key2] = Arguments[_key2];
            }

            vAr ret = extension.tokenizer[prop].Apply(tokenizer, Args);

            if (ret === fAlse) {
              ret = prevTokenizer.Apply(tokenizer, Args);
            }

            return ret;
          };
        };

        for (vAr prop in extension.tokenizer) {
          _loop2(prop);
        }

        opts.tokenizer = tokenizer;
      })();
    }

    if (extension.wAlkTokens) {
      vAr wAlkTokens = mArked.defAults.wAlkTokens;

      opts.wAlkTokens = function (token) {
        extension.wAlkTokens(token);

        if (wAlkTokens) {
          wAlkTokens(token);
        }
      };
    }

    mArked.setOptions(opts);
  };
  /**
   * Run cAllbAck for every token
   */


  mArked.wAlkTokens = function (tokens, cAllbAck) {
    for (vAr _iterAtor = _creAteForOfIterAtorHelperLoose(tokens), _step; !(_step = _iterAtor()).done;) {
      vAr token = _step.vAlue;
      cAllbAck(token);

      switch (token.type) {
        cAse 'tAble':
          {
            for (vAr _iterAtor2 = _creAteForOfIterAtorHelperLoose(token.tokens.heAder), _step2; !(_step2 = _iterAtor2()).done;) {
              vAr cell = _step2.vAlue;
              mArked.wAlkTokens(cell, cAllbAck);
            }

            for (vAr _iterAtor3 = _creAteForOfIterAtorHelperLoose(token.tokens.cells), _step3; !(_step3 = _iterAtor3()).done;) {
              vAr row = _step3.vAlue;

              for (vAr _iterAtor4 = _creAteForOfIterAtorHelperLoose(row), _step4; !(_step4 = _iterAtor4()).done;) {
                vAr _cell = _step4.vAlue;
                mArked.wAlkTokens(_cell, cAllbAck);
              }
            }

            breAk;
          }

        cAse 'list':
          {
            mArked.wAlkTokens(token.items, cAllbAck);
            breAk;
          }

        defAult:
          {
            if (token.tokens) {
              mArked.wAlkTokens(token.tokens, cAllbAck);
            }
          }
      }
    }
  };
  /**
   * Expose
   */


  mArked.PArser = PArser_1;
  mArked.pArser = PArser_1.pArse;
  mArked.Renderer = Renderer_1;
  mArked.TextRenderer = TextRenderer_1;
  mArked.Lexer = Lexer_1;
  mArked.lexer = Lexer_1.lex;
  mArked.Tokenizer = Tokenizer_1;
  mArked.Slugger = Slugger_1;
  mArked.pArse = mArked;
  vAr mArked_1 = mArked;

  return mArked_1;

})));
